
inter.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000000a  00800200  00000b8e  00000c22  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000b8e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000013f  0080020a  0080020a  00000c2c  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000c2c  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000c5c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000238  00000000  00000000  00000ca0  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000220d  00000000  00000000  00000ed8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001319  00000000  00000000  000030e5  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000107d  00000000  00000000  000043fe  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000004b0  00000000  00000000  0000547c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000a71  00000000  00000000  0000592c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000d1b  00000000  00000000  0000639d  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000001a0  00000000  00000000  000070b8  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	81 c0       	rjmp	.+258    	; 0x104 <__ctors_end>
   2:	00 00       	nop
   4:	9e c0       	rjmp	.+316    	; 0x142 <__bad_interrupt>
   6:	00 00       	nop
   8:	9c c0       	rjmp	.+312    	; 0x142 <__bad_interrupt>
   a:	00 00       	nop
   c:	9a c0       	rjmp	.+308    	; 0x142 <__bad_interrupt>
   e:	00 00       	nop
  10:	98 c0       	rjmp	.+304    	; 0x142 <__bad_interrupt>
  12:	00 00       	nop
  14:	96 c0       	rjmp	.+300    	; 0x142 <__bad_interrupt>
  16:	00 00       	nop
  18:	94 c0       	rjmp	.+296    	; 0x142 <__bad_interrupt>
  1a:	00 00       	nop
  1c:	92 c0       	rjmp	.+292    	; 0x142 <__bad_interrupt>
  1e:	00 00       	nop
  20:	90 c0       	rjmp	.+288    	; 0x142 <__bad_interrupt>
  22:	00 00       	nop
  24:	8e c0       	rjmp	.+284    	; 0x142 <__bad_interrupt>
  26:	00 00       	nop
  28:	8c c0       	rjmp	.+280    	; 0x142 <__bad_interrupt>
  2a:	00 00       	nop
  2c:	8a c0       	rjmp	.+276    	; 0x142 <__bad_interrupt>
  2e:	00 00       	nop
  30:	88 c0       	rjmp	.+272    	; 0x142 <__bad_interrupt>
  32:	00 00       	nop
  34:	86 c0       	rjmp	.+268    	; 0x142 <__bad_interrupt>
  36:	00 00       	nop
  38:	84 c0       	rjmp	.+264    	; 0x142 <__bad_interrupt>
  3a:	00 00       	nop
  3c:	82 c0       	rjmp	.+260    	; 0x142 <__bad_interrupt>
  3e:	00 00       	nop
  40:	80 c0       	rjmp	.+256    	; 0x142 <__bad_interrupt>
  42:	00 00       	nop
  44:	7e c0       	rjmp	.+252    	; 0x142 <__bad_interrupt>
  46:	00 00       	nop
  48:	7c c0       	rjmp	.+248    	; 0x142 <__bad_interrupt>
  4a:	00 00       	nop
  4c:	7a c0       	rjmp	.+244    	; 0x142 <__bad_interrupt>
  4e:	00 00       	nop
  50:	78 c0       	rjmp	.+240    	; 0x142 <__bad_interrupt>
  52:	00 00       	nop
  54:	76 c0       	rjmp	.+236    	; 0x142 <__bad_interrupt>
  56:	00 00       	nop
  58:	74 c0       	rjmp	.+232    	; 0x142 <__bad_interrupt>
  5a:	00 00       	nop
  5c:	72 c0       	rjmp	.+228    	; 0x142 <__bad_interrupt>
  5e:	00 00       	nop
  60:	70 c0       	rjmp	.+224    	; 0x142 <__bad_interrupt>
  62:	00 00       	nop
  64:	e2 c4       	rjmp	.+2500   	; 0xa2a <__vector_25>
  66:	00 00       	nop
  68:	6c c0       	rjmp	.+216    	; 0x142 <__bad_interrupt>
  6a:	00 00       	nop
  6c:	09 c5       	rjmp	.+2578   	; 0xa80 <__vector_27>
  6e:	00 00       	nop
  70:	68 c0       	rjmp	.+208    	; 0x142 <__bad_interrupt>
  72:	00 00       	nop
  74:	67 c0       	rjmp	.+206    	; 0x144 <__vector_29>
  76:	00 00       	nop
  78:	64 c0       	rjmp	.+200    	; 0x142 <__bad_interrupt>
  7a:	00 00       	nop
  7c:	62 c0       	rjmp	.+196    	; 0x142 <__bad_interrupt>
  7e:	00 00       	nop
  80:	60 c0       	rjmp	.+192    	; 0x142 <__bad_interrupt>
  82:	00 00       	nop
  84:	5e c0       	rjmp	.+188    	; 0x142 <__bad_interrupt>
  86:	00 00       	nop
  88:	5c c0       	rjmp	.+184    	; 0x142 <__bad_interrupt>
  8a:	00 00       	nop
  8c:	5a c0       	rjmp	.+180    	; 0x142 <__bad_interrupt>
  8e:	00 00       	nop
  90:	58 c0       	rjmp	.+176    	; 0x142 <__bad_interrupt>
  92:	00 00       	nop
  94:	56 c0       	rjmp	.+172    	; 0x142 <__bad_interrupt>
  96:	00 00       	nop
  98:	54 c0       	rjmp	.+168    	; 0x142 <__bad_interrupt>
  9a:	00 00       	nop
  9c:	52 c0       	rjmp	.+164    	; 0x142 <__bad_interrupt>
  9e:	00 00       	nop
  a0:	50 c0       	rjmp	.+160    	; 0x142 <__bad_interrupt>
  a2:	00 00       	nop
  a4:	4e c0       	rjmp	.+156    	; 0x142 <__bad_interrupt>
  a6:	00 00       	nop
  a8:	4c c0       	rjmp	.+152    	; 0x142 <__bad_interrupt>
  aa:	00 00       	nop
  ac:	4a c0       	rjmp	.+148    	; 0x142 <__bad_interrupt>
  ae:	00 00       	nop
  b0:	48 c0       	rjmp	.+144    	; 0x142 <__bad_interrupt>
  b2:	00 00       	nop
  b4:	46 c0       	rjmp	.+140    	; 0x142 <__bad_interrupt>
  b6:	00 00       	nop
  b8:	44 c0       	rjmp	.+136    	; 0x142 <__bad_interrupt>
  ba:	00 00       	nop
  bc:	42 c0       	rjmp	.+132    	; 0x142 <__bad_interrupt>
  be:	00 00       	nop
  c0:	40 c0       	rjmp	.+128    	; 0x142 <__bad_interrupt>
  c2:	00 00       	nop
  c4:	3e c0       	rjmp	.+124    	; 0x142 <__bad_interrupt>
  c6:	00 00       	nop
  c8:	3c c0       	rjmp	.+120    	; 0x142 <__bad_interrupt>
  ca:	00 00       	nop
  cc:	3a c0       	rjmp	.+116    	; 0x142 <__bad_interrupt>
  ce:	00 00       	nop
  d0:	38 c0       	rjmp	.+112    	; 0x142 <__bad_interrupt>
  d2:	00 00       	nop
  d4:	36 c0       	rjmp	.+108    	; 0x142 <__bad_interrupt>
  d6:	00 00       	nop
  d8:	34 c0       	rjmp	.+104    	; 0x142 <__bad_interrupt>
  da:	00 00       	nop
  dc:	32 c0       	rjmp	.+100    	; 0x142 <__bad_interrupt>
  de:	00 00       	nop
  e0:	30 c0       	rjmp	.+96     	; 0x142 <__bad_interrupt>
  e2:	00 00       	nop
  e4:	67 01       	movw	r12, r14
  e6:	6d 01       	movw	r12, r26
  e8:	76 01       	movw	r14, r12
  ea:	82 01       	movw	r16, r4
  ec:	8b 01       	movw	r16, r22
  ee:	97 01       	movw	r18, r14
  f0:	a6 01       	movw	r20, r12
  f2:	b2 01       	movw	r22, r4
  f4:	bb 01       	movw	r22, r22
  f6:	1e 04       	cpc	r1, r14
  f8:	32 04       	cpc	r3, r2
  fa:	3f 04       	cpc	r3, r15
  fc:	4c 04       	cpc	r4, r12
  fe:	59 04       	cpc	r5, r9
 100:	6a 04       	cpc	r6, r10
 102:	7a 04       	cpc	r7, r10

00000104 <__ctors_end>:
 104:	11 24       	eor	r1, r1
 106:	1f be       	out	0x3f, r1	; 63
 108:	cf ef       	ldi	r28, 0xFF	; 255
 10a:	d1 e2       	ldi	r29, 0x21	; 33
 10c:	de bf       	out	0x3e, r29	; 62
 10e:	cd bf       	out	0x3d, r28	; 61
 110:	00 e0       	ldi	r16, 0x00	; 0
 112:	0c bf       	out	0x3c, r16	; 60

00000114 <__do_copy_data>:
 114:	12 e0       	ldi	r17, 0x02	; 2
 116:	a0 e0       	ldi	r26, 0x00	; 0
 118:	b2 e0       	ldi	r27, 0x02	; 2
 11a:	ee e8       	ldi	r30, 0x8E	; 142
 11c:	fb e0       	ldi	r31, 0x0B	; 11
 11e:	00 e0       	ldi	r16, 0x00	; 0
 120:	0b bf       	out	0x3b, r16	; 59
 122:	02 c0       	rjmp	.+4      	; 0x128 <__do_copy_data+0x14>
 124:	07 90       	elpm	r0, Z+
 126:	0d 92       	st	X+, r0
 128:	aa 30       	cpi	r26, 0x0A	; 10
 12a:	b1 07       	cpc	r27, r17
 12c:	d9 f7       	brne	.-10     	; 0x124 <__do_copy_data+0x10>

0000012e <__do_clear_bss>:
 12e:	23 e0       	ldi	r18, 0x03	; 3
 130:	aa e0       	ldi	r26, 0x0A	; 10
 132:	b2 e0       	ldi	r27, 0x02	; 2
 134:	01 c0       	rjmp	.+2      	; 0x138 <.do_clear_bss_start>

00000136 <.do_clear_bss_loop>:
 136:	1d 92       	st	X+, r1

00000138 <.do_clear_bss_start>:
 138:	a9 34       	cpi	r26, 0x49	; 73
 13a:	b2 07       	cpc	r27, r18
 13c:	e1 f7       	brne	.-8      	; 0x136 <.do_clear_bss_loop>
 13e:	c8 d2       	rcall	.+1424   	; 0x6d0 <main>
 140:	24 c5       	rjmp	.+2632   	; 0xb8a <_exit>

00000142 <__bad_interrupt>:
 142:	5e cf       	rjmp	.-324    	; 0x0 <__vectors>

00000144 <__vector_29>:
  return;
}

void adc_stop(void) {
  //stop the ADC
  ADCSRA &= ~(1 << ADSC);
 144:	1f 92       	push	r1
 146:	0f 92       	push	r0
 148:	0f b6       	in	r0, 0x3f	; 63
 14a:	0f 92       	push	r0
 14c:	11 24       	eor	r1, r1
 14e:	0b b6       	in	r0, 0x3b	; 59
 150:	0f 92       	push	r0
 152:	2f 93       	push	r18
 154:	3f 93       	push	r19
 156:	4f 93       	push	r20
 158:	5f 93       	push	r21
 15a:	6f 93       	push	r22
 15c:	7f 93       	push	r23
 15e:	8f 93       	push	r24
 160:	9f 93       	push	r25
 162:	af 93       	push	r26
 164:	bf 93       	push	r27
 166:	ef 93       	push	r30
 168:	ff 93       	push	r31
 16a:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7c0078>
 16e:	90 e0       	ldi	r25, 0x00	; 0
 170:	90 93 12 02 	sts	0x0212, r25	; 0x800212 <data_temp+0x1>
 174:	80 93 11 02 	sts	0x0211, r24	; 0x800211 <data_temp>
 178:	20 91 79 00 	lds	r18, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7c0079>
 17c:	80 91 11 02 	lds	r24, 0x0211	; 0x800211 <data_temp>
 180:	90 91 12 02 	lds	r25, 0x0212	; 0x800212 <data_temp+0x1>
 184:	92 2b       	or	r25, r18
 186:	90 93 12 02 	sts	0x0212, r25	; 0x800212 <data_temp+0x1>
 18a:	80 93 11 02 	sts	0x0211, r24	; 0x800211 <data_temp>
 18e:	20 91 11 02 	lds	r18, 0x0211	; 0x800211 <data_temp>
 192:	30 91 12 02 	lds	r19, 0x0212	; 0x800212 <data_temp+0x1>
 196:	80 91 13 02 	lds	r24, 0x0213	; 0x800213 <data_sum>
 19a:	90 91 14 02 	lds	r25, 0x0214	; 0x800214 <data_sum+0x1>
 19e:	a0 91 15 02 	lds	r26, 0x0215	; 0x800215 <data_sum+0x2>
 1a2:	b0 91 16 02 	lds	r27, 0x0216	; 0x800216 <data_sum+0x3>
 1a6:	82 0f       	add	r24, r18
 1a8:	93 1f       	adc	r25, r19
 1aa:	a1 1d       	adc	r26, r1
 1ac:	b1 1d       	adc	r27, r1
 1ae:	80 93 13 02 	sts	0x0213, r24	; 0x800213 <data_sum>
 1b2:	90 93 14 02 	sts	0x0214, r25	; 0x800214 <data_sum+0x1>
 1b6:	a0 93 15 02 	sts	0x0215, r26	; 0x800215 <data_sum+0x2>
 1ba:	b0 93 16 02 	sts	0x0216, r27	; 0x800216 <data_sum+0x3>
 1be:	80 91 0d 02 	lds	r24, 0x020D	; 0x80020d <cnt>
 1c2:	90 91 0e 02 	lds	r25, 0x020E	; 0x80020e <cnt+0x1>
 1c6:	01 96       	adiw	r24, 0x01	; 1
 1c8:	90 93 0e 02 	sts	0x020E, r25	; 0x80020e <cnt+0x1>
 1cc:	80 93 0d 02 	sts	0x020D, r24	; 0x80020d <cnt>
 1d0:	81 15       	cp	r24, r1
 1d2:	94 40       	sbci	r25, 0x04	; 4
 1d4:	79 f5       	brne	.+94     	; 0x234 <__vector_29+0xf0>
 1d6:	80 91 13 02 	lds	r24, 0x0213	; 0x800213 <data_sum>
 1da:	90 91 14 02 	lds	r25, 0x0214	; 0x800214 <data_sum+0x1>
 1de:	a0 91 15 02 	lds	r26, 0x0215	; 0x800215 <data_sum+0x2>
 1e2:	b0 91 16 02 	lds	r27, 0x0216	; 0x800216 <data_sum+0x3>
 1e6:	07 2e       	mov	r0, r23
 1e8:	7c e0       	ldi	r23, 0x0C	; 12
 1ea:	b6 95       	lsr	r27
 1ec:	a7 95       	ror	r26
 1ee:	97 95       	ror	r25
 1f0:	87 95       	ror	r24
 1f2:	7a 95       	dec	r23
 1f4:	d1 f7       	brne	.-12     	; 0x1ea <__vector_29+0xa6>
 1f6:	70 2d       	mov	r23, r0
 1f8:	90 93 10 02 	sts	0x0210, r25	; 0x800210 <data+0x1>
 1fc:	80 93 0f 02 	sts	0x020F, r24	; 0x80020f <data>
 200:	10 92 13 02 	sts	0x0213, r1	; 0x800213 <data_sum>
 204:	10 92 14 02 	sts	0x0214, r1	; 0x800214 <data_sum+0x1>
 208:	10 92 15 02 	sts	0x0215, r1	; 0x800215 <data_sum+0x2>
 20c:	10 92 16 02 	sts	0x0216, r1	; 0x800216 <data_sum+0x3>
 210:	10 92 0e 02 	sts	0x020E, r1	; 0x80020e <cnt+0x1>
 214:	10 92 0d 02 	sts	0x020D, r1	; 0x80020d <cnt>
 218:	81 e0       	ldi	r24, 0x01	; 1
 21a:	80 93 0c 02 	sts	0x020C, r24	; 0x80020c <have_sample>
 21e:	e0 91 0a 02 	lds	r30, 0x020A	; 0x80020a <__data_end>
 222:	f0 91 0b 02 	lds	r31, 0x020B	; 0x80020b <__data_end+0x1>
 226:	30 97       	sbiw	r30, 0x00	; 0
 228:	29 f0       	breq	.+10     	; 0x234 <__vector_29+0xf0>
 22a:	80 91 0f 02 	lds	r24, 0x020F	; 0x80020f <data>
 22e:	90 91 10 02 	lds	r25, 0x0210	; 0x800210 <data+0x1>
 232:	19 95       	eicall
 234:	ff 91       	pop	r31
 236:	ef 91       	pop	r30
 238:	bf 91       	pop	r27
 23a:	af 91       	pop	r26
 23c:	9f 91       	pop	r25
 23e:	8f 91       	pop	r24
 240:	7f 91       	pop	r23
 242:	6f 91       	pop	r22
 244:	5f 91       	pop	r21
 246:	4f 91       	pop	r20
 248:	3f 91       	pop	r19
 24a:	2f 91       	pop	r18
 24c:	0f 90       	pop	r0
 24e:	0b be       	out	0x3b, r0	; 59
 250:	0f 90       	pop	r0
 252:	0f be       	out	0x3f, r0	; 63
 254:	0f 90       	pop	r0
 256:	1f 90       	pop	r1
 258:	18 95       	reti

0000025a <setAdcAsyncCallback>:
 25a:	90 93 0b 02 	sts	0x020B, r25	; 0x80020b <__data_end+0x1>
 25e:	80 93 0a 02 	sts	0x020A, r24	; 0x80020a <__data_end>
 262:	08 95       	ret

00000264 <adc_start>:
 264:	10 92 7b 00 	sts	0x007B, r1	; 0x80007b <__TEXT_REGION_LENGTH__+0x7c007b>
 268:	ea e7       	ldi	r30, 0x7A	; 122
 26a:	f0 e0       	ldi	r31, 0x00	; 0
 26c:	90 81       	ld	r25, Z
 26e:	97 60       	ori	r25, 0x07	; 7
 270:	90 83       	st	Z, r25
 272:	ec e7       	ldi	r30, 0x7C	; 124
 274:	f0 e0       	ldi	r31, 0x00	; 0
 276:	90 81       	ld	r25, Z
 278:	90 64       	ori	r25, 0x40	; 64
 27a:	90 83       	st	Z, r25
 27c:	88 23       	and	r24, r24
 27e:	19 f0       	breq	.+6      	; 0x286 <adc_start+0x22>
 280:	80 81       	ld	r24, Z
 282:	80 62       	ori	r24, 0x20	; 32
 284:	80 83       	st	Z, r24
 286:	ea e7       	ldi	r30, 0x7A	; 122
 288:	f0 e0       	ldi	r31, 0x00	; 0
 28a:	80 81       	ld	r24, Z
 28c:	80 62       	ori	r24, 0x20	; 32
 28e:	80 83       	st	Z, r24
 290:	80 81       	ld	r24, Z
 292:	80 68       	ori	r24, 0x80	; 128
 294:	80 83       	st	Z, r24
 296:	80 81       	ld	r24, Z
 298:	88 60       	ori	r24, 0x08	; 8
 29a:	80 83       	st	Z, r24
 29c:	ac e7       	ldi	r26, 0x7C	; 124
 29e:	b0 e0       	ldi	r27, 0x00	; 0
 2a0:	8c 91       	ld	r24, X
 2a2:	80 7f       	andi	r24, 0xF0	; 240
 2a4:	8c 93       	st	X, r24
 2a6:	80 81       	ld	r24, Z
 2a8:	80 64       	ori	r24, 0x40	; 64
 2aa:	80 83       	st	Z, r24
 2ac:	08 95       	ret

000002ae <adc_change>:
  return;
}

void adc_change(u08 chan) {
  //stop the ADC
  ADCSRA &= ~(1 << ADSC);
 2ae:	ea e7       	ldi	r30, 0x7A	; 122
 2b0:	f0 e0       	ldi	r31, 0x00	; 0
 2b2:	90 81       	ld	r25, Z
 2b4:	9f 7b       	andi	r25, 0xBF	; 191
 2b6:	90 83       	st	Z, r25

  switch (chan) {
 2b8:	90 e0       	ldi	r25, 0x00	; 0
 2ba:	89 30       	cpi	r24, 0x09	; 9
 2bc:	91 05       	cpc	r25, r1
 2be:	08 f0       	brcs	.+2      	; 0x2c2 <adc_change+0x14>
 2c0:	62 c0       	rjmp	.+196    	; 0x386 <adc_change+0xd8>
 2c2:	fc 01       	movw	r30, r24
 2c4:	88 27       	eor	r24, r24
 2c6:	ee 58       	subi	r30, 0x8E	; 142
 2c8:	ff 4f       	sbci	r31, 0xFF	; 255
 2ca:	8f 4f       	sbci	r24, 0xFF	; 255
 2cc:	26 c4       	rjmp	.+2124   	; 0xb1a <__tablejump2__>
    case 0://binary 0 (reading downwards)
      ADMUX &= ~(1 << MUX0)
 2ce:	ec e7       	ldi	r30, 0x7C	; 124
 2d0:	f0 e0       	ldi	r31, 0x00	; 0
 2d2:	80 81       	ld	r24, Z
 2d4:	80 7f       	andi	r24, 0xF0	; 240
 2d6:	80 83       	st	Z, r24
            &  ~(1 << MUX1)
            &  ~(1 << MUX2)
            &  ~(1 << MUX3);
      break;
 2d8:	56 c0       	rjmp	.+172    	; 0x386 <adc_change+0xd8>
    case 1://binary 1
      ADMUX |=  (1 << MUX0);
 2da:	ec e7       	ldi	r30, 0x7C	; 124
 2dc:	f0 e0       	ldi	r31, 0x00	; 0
 2de:	80 81       	ld	r24, Z
 2e0:	81 60       	ori	r24, 0x01	; 1
 2e2:	80 83       	st	Z, r24
      ADMUX &= ~(1 << MUX1)
 2e4:	80 81       	ld	r24, Z
 2e6:	81 7f       	andi	r24, 0xF1	; 241
 2e8:	80 83       	st	Z, r24
            &  ~(1 << MUX2)
            &  ~(1 << MUX3);
      break;
 2ea:	4d c0       	rjmp	.+154    	; 0x386 <adc_change+0xd8>
    case 2://binary 2
      ADMUX &= ~(1 << MUX0);
 2ec:	ec e7       	ldi	r30, 0x7C	; 124
 2ee:	f0 e0       	ldi	r31, 0x00	; 0
 2f0:	80 81       	ld	r24, Z
 2f2:	8e 7f       	andi	r24, 0xFE	; 254
 2f4:	80 83       	st	Z, r24
      ADMUX |=  (1 << MUX1);
 2f6:	80 81       	ld	r24, Z
 2f8:	82 60       	ori	r24, 0x02	; 2
 2fa:	80 83       	st	Z, r24
      ADMUX &= ~(1 << MUX2)
 2fc:	80 81       	ld	r24, Z
 2fe:	83 7f       	andi	r24, 0xF3	; 243
 300:	80 83       	st	Z, r24
            &  ~(1 << MUX3);
      break;
 302:	41 c0       	rjmp	.+130    	; 0x386 <adc_change+0xd8>
    case 3: //should have the picture by now
      ADMUX |=  (1 << MUX0)
 304:	ec e7       	ldi	r30, 0x7C	; 124
 306:	f0 e0       	ldi	r31, 0x00	; 0
 308:	80 81       	ld	r24, Z
 30a:	83 60       	ori	r24, 0x03	; 3
 30c:	80 83       	st	Z, r24
            |   (1 << MUX1);
      ADMUX &= ~(1 << MUX2)
 30e:	80 81       	ld	r24, Z
 310:	83 7f       	andi	r24, 0xF3	; 243
 312:	80 83       	st	Z, r24
            &  ~(1 << MUX3);
      break;
 314:	38 c0       	rjmp	.+112    	; 0x386 <adc_change+0xd8>
    case 4:
      ADMUX &= ~(1 << MUX0)
 316:	ec e7       	ldi	r30, 0x7C	; 124
 318:	f0 e0       	ldi	r31, 0x00	; 0
 31a:	80 81       	ld	r24, Z
 31c:	8c 7f       	andi	r24, 0xFC	; 252
 31e:	80 83       	st	Z, r24
            &  ~(1 << MUX1);
      ADMUX |=  (1 << MUX2);
 320:	80 81       	ld	r24, Z
 322:	84 60       	ori	r24, 0x04	; 4
 324:	80 83       	st	Z, r24
      ADMUX &= ~(1 << MUX3);
 326:	80 81       	ld	r24, Z
 328:	87 7f       	andi	r24, 0xF7	; 247
 32a:	80 83       	st	Z, r24
      break;
 32c:	2c c0       	rjmp	.+88     	; 0x386 <adc_change+0xd8>
    case 5:
      ADMUX |=  (1 << MUX0);
 32e:	ec e7       	ldi	r30, 0x7C	; 124
 330:	f0 e0       	ldi	r31, 0x00	; 0
 332:	80 81       	ld	r24, Z
 334:	81 60       	ori	r24, 0x01	; 1
 336:	80 83       	st	Z, r24
      ADMUX &= ~(1 << MUX1);
 338:	80 81       	ld	r24, Z
 33a:	8d 7f       	andi	r24, 0xFD	; 253
 33c:	80 83       	st	Z, r24
      ADMUX |=  (1 << MUX2);
 33e:	80 81       	ld	r24, Z
 340:	84 60       	ori	r24, 0x04	; 4
 342:	80 83       	st	Z, r24
      ADMUX &= ~(1 << MUX3);
 344:	80 81       	ld	r24, Z
 346:	87 7f       	andi	r24, 0xF7	; 247
 348:	80 83       	st	Z, r24
      break;
 34a:	1d c0       	rjmp	.+58     	; 0x386 <adc_change+0xd8>
    case 6:
      ADMUX &= ~(1 << MUX0);
 34c:	ec e7       	ldi	r30, 0x7C	; 124
 34e:	f0 e0       	ldi	r31, 0x00	; 0
 350:	80 81       	ld	r24, Z
 352:	8e 7f       	andi	r24, 0xFE	; 254
 354:	80 83       	st	Z, r24
      ADMUX |=  (1 << MUX1)
 356:	80 81       	ld	r24, Z
 358:	86 60       	ori	r24, 0x06	; 6
 35a:	80 83       	st	Z, r24
            |   (1 << MUX2);
      ADMUX &= ~(1 << MUX3);
 35c:	80 81       	ld	r24, Z
 35e:	87 7f       	andi	r24, 0xF7	; 247
 360:	80 83       	st	Z, r24
      break;
 362:	11 c0       	rjmp	.+34     	; 0x386 <adc_change+0xd8>
    case 7:
      ADMUX |=  (1 << MUX0)
 364:	ec e7       	ldi	r30, 0x7C	; 124
 366:	f0 e0       	ldi	r31, 0x00	; 0
 368:	80 81       	ld	r24, Z
 36a:	87 60       	ori	r24, 0x07	; 7
 36c:	80 83       	st	Z, r24
            |   (1 << MUX1)
            |   (1 << MUX2);
      ADMUX &= ~(1 << MUX3);
 36e:	80 81       	ld	r24, Z
 370:	87 7f       	andi	r24, 0xF7	; 247
 372:	80 83       	st	Z, r24
      break;
 374:	08 c0       	rjmp	.+16     	; 0x386 <adc_change+0xd8>
    case 8:
      ADMUX &= ~(1 << MUX0)
 376:	ec e7       	ldi	r30, 0x7C	; 124
 378:	f0 e0       	ldi	r31, 0x00	; 0
 37a:	80 81       	ld	r24, Z
 37c:	88 7f       	andi	r24, 0xF8	; 248
 37e:	80 83       	st	Z, r24
            &  ~(1 << MUX1)
            &  ~(1 << MUX2);
      ADMUX |=  (1 << MUX3);
 380:	80 81       	ld	r24, Z
 382:	88 60       	ori	r24, 0x08	; 8
 384:	80 83       	st	Z, r24
      break;
  }
  //re-enable ADC conversions now that the channel is selected
  ADCSRA |= (1 << ADSC);
 386:	ea e7       	ldi	r30, 0x7A	; 122
 388:	f0 e0       	ldi	r31, 0x00	; 0
 38a:	80 81       	ld	r24, Z
 38c:	80 64       	ori	r24, 0x40	; 64
 38e:	80 83       	st	Z, r24
 390:	08 95       	ret

00000392 <comm_RxCallback>:


BOOL CommGetData(struct DataFrame* pdf)
{
	return data_GetData(pdf);
}
 392:	3a d3       	rcall	.+1652   	; 0xa08 <uartRecieveByte>
 394:	45 c2       	rjmp	.+1162   	; 0x820 <data_RecieveByte>
 396:	08 95       	ret

00000398 <CommInit>:
 398:	cf 92       	push	r12
 39a:	df 92       	push	r13
 39c:	ef 92       	push	r14
 39e:	ff 92       	push	r15
 3a0:	6b 01       	movw	r12, r22
 3a2:	7c 01       	movw	r14, r24
 3a4:	89 ec       	ldi	r24, 0xC9	; 201
 3a6:	91 e0       	ldi	r25, 0x01	; 1
 3a8:	32 d3       	rcall	.+1636   	; 0xa0e <uartSetRxCallback>
 3aa:	8e e0       	ldi	r24, 0x0E	; 14
 3ac:	92 e0       	ldi	r25, 0x02	; 2
 3ae:	36 d3       	rcall	.+1644   	; 0xa1c <uartSetTxCallback>
 3b0:	e5 d2       	rcall	.+1482   	; 0x97c <uartInit>
 3b2:	c7 01       	movw	r24, r14
 3b4:	b6 01       	movw	r22, r12
 3b6:	ec d2       	rcall	.+1496   	; 0x990 <uartSetBaudRate>
 3b8:	ff 90       	pop	r15
 3ba:	ef 90       	pop	r14
 3bc:	df 90       	pop	r13
 3be:	cf 90       	pop	r12
 3c0:	08 95       	ret

000003c2 <CommIsFree>:
 3c2:	81 e0       	ldi	r24, 0x01	; 1
 3c4:	90 91 17 02 	lds	r25, 0x0217	; 0x800217 <bHaveMoreData>
 3c8:	91 11       	cpse	r25, r1
 3ca:	80 e0       	ldi	r24, 0x00	; 0
 3cc:	08 95       	ret

000003ce <comm_SendNextByte>:

void comm_SendNextByte()
{
	bHaveMoreData = data_SendNextByte(&nNextByte);
 3ce:	88 e1       	ldi	r24, 0x18	; 24
 3d0:	92 e0       	ldi	r25, 0x02	; 2
 3d2:	a5 d1       	rcall	.+842    	; 0x71e <data_SendNextByte>
 3d4:	80 93 17 02 	sts	0x0217, r24	; 0x800217 <bHaveMoreData>
	uartSendByte(nNextByte);
 3d8:	80 91 18 02 	lds	r24, 0x0218	; 0x800218 <nNextByte>
 3dc:	0d c3       	rjmp	.+1562   	; 0x9f8 <uartSendByte>
 3de:	08 95       	ret

000003e0 <CommSendData>:
{
	return !bHaveMoreData;
}

BOOL CommSendData(u08 nAddressFrom, u08 nAddressTo, u08 nCmd, u08 nDataLen, u08* pData)
{
 3e0:	0f 93       	push	r16
 3e2:	1f 93       	push	r17
	if (bHaveMoreData)
 3e4:	90 91 17 02 	lds	r25, 0x0217	; 0x800217 <bHaveMoreData>
 3e8:	91 11       	cpse	r25, r1
 3ea:	14 c0       	rjmp	.+40     	; 0x414 <__LOCK_REGION_LENGTH__+0x14>
		return FALSE;

	dfOutput.Header.nCmd = nCmd;
 3ec:	ee e2       	ldi	r30, 0x2E	; 46
 3ee:	f2 e0       	ldi	r31, 0x02	; 2
 3f0:	43 83       	std	Z+3, r20	; 0x03
	dfOutput.Header.nAddressFrom = nAddressFrom;
 3f2:	81 83       	std	Z+1, r24	; 0x01
	dfOutput.Header.nAddressTo = nAddressTo;
 3f4:	62 83       	std	Z+2, r22	; 0x02
	dfOutput.Header.nDataLen = nDataLen;
 3f6:	24 83       	std	Z+4, r18	; 0x04
	if (nDataLen > 0)
 3f8:	22 23       	and	r18, r18
 3fa:	31 f0       	breq	.+12     	; 0x408 <__LOCK_REGION_LENGTH__+0x8>
		memcpy(&dfOutput.Data, pData, nDataLen);
 3fc:	42 2f       	mov	r20, r18
 3fe:	50 e0       	ldi	r21, 0x00	; 0
 400:	b8 01       	movw	r22, r16
 402:	84 e3       	ldi	r24, 0x34	; 52
 404:	92 e0       	ldi	r25, 0x02	; 2
 406:	91 d3       	rcall	.+1826   	; 0xb2a <memcpy>
	data_SendFrame(&dfOutput);
 408:	8e e2       	ldi	r24, 0x2E	; 46
 40a:	92 e0       	ldi	r25, 0x02	; 2
	comm_SendNextByte();
 40c:	97 d2       	rcall	.+1326   	; 0x93c <data_SendFrame>
 40e:	df df       	rcall	.-66     	; 0x3ce <comm_SendNextByte>
	return TRUE;
 410:	8f ef       	ldi	r24, 0xFF	; 255
 412:	01 c0       	rjmp	.+2      	; 0x416 <__LOCK_REGION_LENGTH__+0x16>
}

BOOL CommSendData(u08 nAddressFrom, u08 nAddressTo, u08 nCmd, u08 nDataLen, u08* pData)
{
	if (bHaveMoreData)
		return FALSE;
 414:	80 e0       	ldi	r24, 0x00	; 0
	if (nDataLen > 0)
		memcpy(&dfOutput.Data, pData, nDataLen);
	data_SendFrame(&dfOutput);
	comm_SendNextByte();
	return TRUE;
}
 416:	1f 91       	pop	r17
 418:	0f 91       	pop	r16
 41a:	08 95       	ret

0000041c <comm_TxCallback>:
	data_RecieveByte(uartRecieveByte());
}

void comm_TxCallback()
{
	if (!bHaveMoreData)
 41c:	80 91 17 02 	lds	r24, 0x0217	; 0x800217 <bHaveMoreData>
 420:	81 11       	cpse	r24, r1
		return;
	
	comm_SendNextByte();
 422:	d5 cf       	rjmp	.-86     	; 0x3ce <comm_SendNextByte>
 424:	08 95       	ret

00000426 <adcCallbackProc>:
				break;
			case 2:
				PORTC &= ~(1 << PC3);
				break;
			case 3:
				PORTC &= ~(1 << PC5);
 426:	f8 94       	cli
 428:	e0 91 24 02 	lds	r30, 0x0224	; 0x800224 <currentAdcChannel>
 42c:	91 e0       	ldi	r25, 0x01	; 1
 42e:	9e 0f       	add	r25, r30
 430:	90 93 24 02 	sts	0x0224, r25	; 0x800224 <currentAdcChannel>
 434:	f0 e0       	ldi	r31, 0x00	; 0
 436:	eb 5d       	subi	r30, 0xDB	; 219
 438:	fd 4f       	sbci	r31, 0xFD	; 253
 43a:	80 83       	st	Z, r24
 43c:	92 30       	cpi	r25, 0x02	; 2
 43e:	11 f4       	brne	.+4      	; 0x444 <adcCallbackProc+0x1e>
 440:	10 92 24 02 	sts	0x0224, r1	; 0x800224 <currentAdcChannel>
 444:	80 91 24 02 	lds	r24, 0x0224	; 0x800224 <currentAdcChannel>
 448:	32 df       	rcall	.-412    	; 0x2ae <adc_change>
 44a:	78 94       	sei
 44c:	08 95       	ret

0000044e <getSunSample>:
		toggleOutput(DRL_PIN, TRUE);
		firstRun = FALSE;
	}
}

BOOL getSunSample(u08* val) {
 44e:	cf 92       	push	r12
 450:	df 92       	push	r13
 452:	ef 92       	push	r14
 454:	ff 92       	push	r15
 456:	0f 93       	push	r16
 458:	1f 93       	push	r17
 45a:	cf 93       	push	r28
 45c:	df 93       	push	r29
 45e:	ec 01       	movw	r28, r24
	sunSamplesSum += adcBuff[ADC_SUNLIGHT];
 460:	20 91 25 02 	lds	r18, 0x0225	; 0x800225 <adcBuff>
 464:	80 91 19 02 	lds	r24, 0x0219	; 0x800219 <sunSamplesSum>
 468:	90 91 1a 02 	lds	r25, 0x021A	; 0x80021a <sunSamplesSum+0x1>
 46c:	a0 91 1b 02 	lds	r26, 0x021B	; 0x80021b <sunSamplesSum+0x2>
 470:	b0 91 1c 02 	lds	r27, 0x021C	; 0x80021c <sunSamplesSum+0x3>
 474:	bc 01       	movw	r22, r24
 476:	cd 01       	movw	r24, r26
 478:	62 0f       	add	r22, r18
 47a:	71 1d       	adc	r23, r1
 47c:	81 1d       	adc	r24, r1
 47e:	91 1d       	adc	r25, r1
 480:	60 93 19 02 	sts	0x0219, r22	; 0x800219 <sunSamplesSum>
 484:	70 93 1a 02 	sts	0x021A, r23	; 0x80021a <sunSamplesSum+0x1>
 488:	80 93 1b 02 	sts	0x021B, r24	; 0x80021b <sunSamplesSum+0x2>
 48c:	90 93 1c 02 	sts	0x021C, r25	; 0x80021c <sunSamplesSum+0x3>
	if (++sunSamplesCount == sunSamplesMax) {
 490:	00 91 1d 02 	lds	r16, 0x021D	; 0x80021d <sunSamplesCount>
 494:	10 91 1e 02 	lds	r17, 0x021E	; 0x80021e <sunSamplesCount+0x1>
 498:	20 91 1f 02 	lds	r18, 0x021F	; 0x80021f <sunSamplesCount+0x2>
 49c:	30 91 20 02 	lds	r19, 0x0220	; 0x800220 <sunSamplesCount+0x3>
 4a0:	a9 01       	movw	r20, r18
 4a2:	98 01       	movw	r18, r16
 4a4:	2f 5f       	subi	r18, 0xFF	; 255
 4a6:	3f 4f       	sbci	r19, 0xFF	; 255
 4a8:	4f 4f       	sbci	r20, 0xFF	; 255
 4aa:	5f 4f       	sbci	r21, 0xFF	; 255
 4ac:	20 93 1d 02 	sts	0x021D, r18	; 0x80021d <sunSamplesCount>
 4b0:	30 93 1e 02 	sts	0x021E, r19	; 0x80021e <sunSamplesCount+0x1>
 4b4:	40 93 1f 02 	sts	0x021F, r20	; 0x80021f <sunSamplesCount+0x2>
 4b8:	50 93 20 02 	sts	0x0220, r21	; 0x800220 <sunSamplesCount+0x3>
 4bc:	c0 90 02 02 	lds	r12, 0x0202	; 0x800202 <sunSamplesMax>
 4c0:	d0 90 03 02 	lds	r13, 0x0203	; 0x800203 <sunSamplesMax+0x1>
 4c4:	e0 90 04 02 	lds	r14, 0x0204	; 0x800204 <sunSamplesMax+0x2>
 4c8:	f0 90 05 02 	lds	r15, 0x0205	; 0x800205 <sunSamplesMax+0x3>
 4cc:	2c 15       	cp	r18, r12
 4ce:	3d 05       	cpc	r19, r13
 4d0:	4e 05       	cpc	r20, r14
 4d2:	5f 05       	cpc	r21, r15
 4d4:	31 f5       	brne	.+76     	; 0x522 <getSunSample+0xd4>
		u32 v = sunSamplesSum / sunSamplesMax;
		*val = (u08)v;
 4d6:	ff d2       	rcall	.+1534   	; 0xad6 <__udivmodsi4>
 4d8:	28 83       	st	Y, r18
		sunSamplesSum = 0;
 4da:	10 92 19 02 	sts	0x0219, r1	; 0x800219 <sunSamplesSum>
 4de:	10 92 1a 02 	sts	0x021A, r1	; 0x80021a <sunSamplesSum+0x1>
 4e2:	10 92 1b 02 	sts	0x021B, r1	; 0x80021b <sunSamplesSum+0x2>
 4e6:	10 92 1c 02 	sts	0x021C, r1	; 0x80021c <sunSamplesSum+0x3>
		sunSamplesCount = 0;
 4ea:	10 92 1d 02 	sts	0x021D, r1	; 0x80021d <sunSamplesCount>
 4ee:	10 92 1e 02 	sts	0x021E, r1	; 0x80021e <sunSamplesCount+0x1>
 4f2:	10 92 1f 02 	sts	0x021F, r1	; 0x80021f <sunSamplesCount+0x2>
 4f6:	10 92 20 02 	sts	0x0220, r1	; 0x800220 <sunSamplesCount+0x3>
		if (isStartup) {
 4fa:	80 91 01 02 	lds	r24, 0x0201	; 0x800201 <isStartup>
 4fe:	88 23       	and	r24, r24
 500:	91 f0       	breq	.+36     	; 0x526 <getSunSample+0xd8>
			isStartup = FALSE;
 502:	10 92 01 02 	sts	0x0201, r1	; 0x800201 <isStartup>
			sunSamplesMax = SUN_SAMPLES_MAX_COUNT;
 506:	80 e0       	ldi	r24, 0x00	; 0
 508:	95 e3       	ldi	r25, 0x35	; 53
 50a:	ac e0       	ldi	r26, 0x0C	; 12
 50c:	b0 e0       	ldi	r27, 0x00	; 0
 50e:	80 93 02 02 	sts	0x0202, r24	; 0x800202 <sunSamplesMax>
 512:	90 93 03 02 	sts	0x0203, r25	; 0x800203 <sunSamplesMax+0x1>
 516:	a0 93 04 02 	sts	0x0204, r26	; 0x800204 <sunSamplesMax+0x2>
 51a:	b0 93 05 02 	sts	0x0205, r27	; 0x800205 <sunSamplesMax+0x3>
		}
		return TRUE;
 51e:	8f ef       	ldi	r24, 0xFF	; 255
 520:	03 c0       	rjmp	.+6      	; 0x528 <getSunSample+0xda>
	}
	
	return FALSE;
 522:	80 e0       	ldi	r24, 0x00	; 0
 524:	01 c0       	rjmp	.+2      	; 0x528 <getSunSample+0xda>
		sunSamplesCount = 0;
		if (isStartup) {
			isStartup = FALSE;
			sunSamplesMax = SUN_SAMPLES_MAX_COUNT;
		}
		return TRUE;
 526:	8f ef       	ldi	r24, 0xFF	; 255
	}
	
	return FALSE;
}
 528:	df 91       	pop	r29
 52a:	cf 91       	pop	r28
 52c:	1f 91       	pop	r17
 52e:	0f 91       	pop	r16
 530:	ff 90       	pop	r15
 532:	ef 90       	pop	r14
 534:	df 90       	pop	r13
 536:	cf 90       	pop	r12
 538:	08 95       	ret

0000053a <processLightsOn>:
			processLightsOff();
			break;
	}
}

void processLightsOn() {
 53a:	cf 93       	push	r28
 53c:	df 93       	push	r29
 53e:	1f 92       	push	r1
 540:	cd b7       	in	r28, 0x3d	; 61
 542:	de b7       	in	r29, 0x3e	; 62
	u08 sunlight;
	
	if (!getSunSample(&sunlight))
 544:	ce 01       	movw	r24, r28
 546:	01 96       	adiw	r24, 0x01	; 1
 548:	82 df       	rcall	.-252    	; 0x44e <getSunSample>
 54a:	88 23       	and	r24, r24
 54c:	59 f0       	breq	.+22     	; 0x564 <processLightsOn+0x2a>
		return;
		
	if (sunlight >= deviceConfig.lightsOffThreshold)	{
 54e:	90 91 76 02 	lds	r25, 0x0276	; 0x800276 <deviceConfig+0x2>
 552:	89 81       	ldd	r24, Y+1	; 0x01
 554:	89 17       	cp	r24, r25
 556:	30 f0       	brcs	.+12     	; 0x564 <processLightsOn+0x2a>
		lightsState = LIGHTS_STATE_OFF;
 558:	10 92 23 02 	sts	0x0223, r1	; 0x800223 <lightsState>
		firstRun = FALSE;
 55c:	10 92 00 02 	sts	0x0200, r1	; 0x800200 <__DATA_REGION_ORIGIN__>
		switch (output) {
			case 0:
				PORTD |= (1 << PD7);
				break;
			case 1:
				PORTC |= (1 << PC1);
 560:	41 9a       	sbi	0x08, 1	; 8
				break;
			case 1:
				PORTC &= ~(1 << PC1);
				break;
			case 2:
				PORTC &= ~(1 << PC3);
 562:	43 98       	cbi	0x08, 3	; 8
		lightsState = LIGHTS_STATE_OFF;
		firstRun = FALSE;
		toggleOutput(DRL_PIN, TRUE);
		toggleOutput(HEADLIGHT_PIN, FALSE);
	}
}
 564:	0f 90       	pop	r0
 566:	df 91       	pop	r29
 568:	cf 91       	pop	r28
 56a:	08 95       	ret

0000056c <processLightsOff>:

void processLightsOff() {
 56c:	cf 93       	push	r28
 56e:	df 93       	push	r29
 570:	1f 92       	push	r1
 572:	cd b7       	in	r28, 0x3d	; 61
 574:	de b7       	in	r29, 0x3e	; 62
	u08 sunlight;
	
	if (!getSunSample(&sunlight))
 576:	ce 01       	movw	r24, r28
 578:	01 96       	adiw	r24, 0x01	; 1
 57a:	69 df       	rcall	.-302    	; 0x44e <getSunSample>
 57c:	88 23       	and	r24, r24
 57e:	d9 f0       	breq	.+54     	; 0x5b6 <processLightsOff+0x4a>
		return;
	
	if (sunlight <= deviceConfig.lightsOnThreshold) {
 580:	90 91 75 02 	lds	r25, 0x0275	; 0x800275 <deviceConfig+0x1>
 584:	89 81       	ldd	r24, Y+1	; 0x01
 586:	98 17       	cp	r25, r24
 588:	58 f0       	brcs	.+22     	; 0x5a0 <processLightsOff+0x34>
		lightsState = LIGHTS_STATE_ON;
 58a:	81 e0       	ldi	r24, 0x01	; 1
 58c:	80 93 23 02 	sts	0x0223, r24	; 0x800223 <lightsState>
		firstRun = FALSE;
 590:	10 92 00 02 	sts	0x0200, r1	; 0x800200 <__DATA_REGION_ORIGIN__>
		if (!drlForced)
 594:	80 91 21 02 	lds	r24, 0x0221	; 0x800221 <drlForced>
 598:	81 11       	cpse	r24, r1
 59a:	01 c0       	rjmp	.+2      	; 0x59e <processLightsOff+0x32>
		switch (output) {
			case 0:
				PORTD &= ~(1 << PD7);
				break;
			case 1:
				PORTC &= ~(1 << PC1);
 59c:	41 98       	cbi	0x08, 1	; 8
				break;
			case 1:
				PORTC |= (1 << PC1);
				break;
			case 2:
				PORTC |= (1 << PC3);
 59e:	43 9a       	sbi	0x08, 3	; 8
		if (!drlForced)
			toggleOutput(DRL_PIN, FALSE);
		toggleOutput(HEADLIGHT_PIN, TRUE);
	}
	
	if (firstRun && (lightsState == LIGHTS_STATE_OFF)) {
 5a0:	80 91 00 02 	lds	r24, 0x0200	; 0x800200 <__DATA_REGION_ORIGIN__>
 5a4:	88 23       	and	r24, r24
 5a6:	39 f0       	breq	.+14     	; 0x5b6 <processLightsOff+0x4a>
 5a8:	80 91 23 02 	lds	r24, 0x0223	; 0x800223 <lightsState>
 5ac:	81 11       	cpse	r24, r1
 5ae:	03 c0       	rjmp	.+6      	; 0x5b6 <processLightsOff+0x4a>
		switch (output) {
			case 0:
				PORTD |= (1 << PD7);
				break;
			case 1:
				PORTC |= (1 << PC1);
 5b0:	41 9a       	sbi	0x08, 1	; 8
		toggleOutput(HEADLIGHT_PIN, TRUE);
	}
	
	if (firstRun && (lightsState == LIGHTS_STATE_OFF)) {
		toggleOutput(DRL_PIN, TRUE);
		firstRun = FALSE;
 5b2:	10 92 00 02 	sts	0x0200, r1	; 0x800200 <__DATA_REGION_ORIGIN__>
	}
}
 5b6:	0f 90       	pop	r0
 5b8:	df 91       	pop	r29
 5ba:	cf 91       	pop	r28
 5bc:	08 95       	ret

000005be <processLights>:
			}
	}
}

void processLights() {
	if (adcBuff[ADC_BATT] < deviceConfig.minVoltage)
 5be:	90 91 26 02 	lds	r25, 0x0226	; 0x800226 <adcBuff+0x1>
 5c2:	80 91 74 02 	lds	r24, 0x0274	; 0x800274 <deviceConfig>
 5c6:	98 17       	cp	r25, r24
 5c8:	48 f0       	brcs	.+18     	; 0x5dc <processLights+0x1e>
		return;
		
	switch(lightsState) {	
 5ca:	80 91 23 02 	lds	r24, 0x0223	; 0x800223 <lightsState>
 5ce:	88 23       	and	r24, r24
 5d0:	21 f0       	breq	.+8      	; 0x5da <processLights+0x1c>
 5d2:	81 30       	cpi	r24, 0x01	; 1
 5d4:	19 f4       	brne	.+6      	; 0x5dc <processLights+0x1e>
			case LIGHTS_STATE_ON:
			processLightsOn();
 5d6:	b1 cf       	rjmp	.-158    	; 0x53a <processLightsOn>
			break;
			
			case LIGHTS_STATE_OFF:
			processLightsOff();
 5d8:	08 95       	ret
 5da:	c8 cf       	rjmp	.-112    	; 0x56c <processLightsOff>
 5dc:	08 95       	ret

000005de <readDeviceConfig>:
	return FALSE;
}

void readDeviceConfig()
{
	eeprom_read_block(&deviceConfig, (void *)1, sizeof(deviceConfig));
 5de:	43 e0       	ldi	r20, 0x03	; 3
 5e0:	50 e0       	ldi	r21, 0x00	; 0
 5e2:	61 e0       	ldi	r22, 0x01	; 1
 5e4:	70 e0       	ldi	r23, 0x00	; 0
 5e6:	84 e7       	ldi	r24, 0x74	; 116
 5e8:	92 e0       	ldi	r25, 0x02	; 2
 5ea:	a8 c2       	rjmp	.+1360   	; 0xb3c <eeprom_read_block>
 5ec:	08 95       	ret

000005ee <init>:
}

void init() {
	//setDefaultConfig();
	
	readDeviceConfig();
 5ee:	f7 df       	rcall	.-18     	; 0x5de <readDeviceConfig>
	
	setAdcAsyncCallback(adcCallbackProc);
 5f0:	83 e1       	ldi	r24, 0x13	; 19
 5f2:	92 e0       	ldi	r25, 0x02	; 2
 5f4:	32 de       	rcall	.-924    	; 0x25a <setAdcAsyncCallback>
	adc_start(0);
 5f6:	80 e0       	ldi	r24, 0x00	; 0
 5f8:	35 de       	rcall	.-918    	; 0x264 <adc_start>
 5fa:	60 e0       	ldi	r22, 0x00	; 0
	
	CommInit(19200);
 5fc:	7b e4       	ldi	r23, 0x4B	; 75
 5fe:	80 e0       	ldi	r24, 0x00	; 0
 600:	90 e0       	ldi	r25, 0x00	; 0
 602:	ca de       	rcall	.-620    	; 0x398 <CommInit>
 604:	8f ef       	ldi	r24, 0xFF	; 255

	DDRA = 0xFF;
 606:	81 b9       	out	0x01, r24	; 1
 608:	87 b9       	out	0x07, r24	; 7
	DDRC = 0xFF;
 60a:	8a b9       	out	0x0a, r24	; 10
	DDRD = 0xFF;
 60c:	41 98       	cbi	0x08, 1	; 8
		switch (output) {
			case 0:
				PORTD &= ~(1 << PD7);
				break;
			case 1:
				PORTC &= ~(1 << PC1);
 60e:	43 98       	cbi	0x08, 3	; 8
				break;
			case 2:
				PORTC &= ~(1 << PC3);
 610:	78 94       	sei
	DDRD = 0xFF;

	toggleOutput(DRL_PIN, 0);
	toggleOutput(HEADLIGHT_PIN, 0);
	
	sei();
 612:	08 95       	ret

00000614 <writeDeviceConfig>:
 614:	43 e0       	ldi	r20, 0x03	; 3
	eeprom_read_block(&deviceConfig, (void *)1, sizeof(deviceConfig));
}

void writeDeviceConfig()
{
	eeprom_write_block(&deviceConfig, (void *)1, sizeof(deviceConfig));
 616:	50 e0       	ldi	r21, 0x00	; 0
 618:	61 e0       	ldi	r22, 0x01	; 1
 61a:	70 e0       	ldi	r23, 0x00	; 0
 61c:	84 e7       	ldi	r24, 0x74	; 116
 61e:	92 e0       	ldi	r25, 0x02	; 2
 620:	9d c2       	rjmp	.+1338   	; 0xb5c <eeprom_write_block>
 622:	08 95       	ret

00000624 <processData>:
		
		processLights();
	}
}

void processData() {
 624:	0f 93       	push	r16
 626:	1f 93       	push	r17
	switch(df.Header.nCmd) {
 628:	80 91 7a 02 	lds	r24, 0x027A	; 0x80027a <df+0x3>
 62c:	8d 30       	cpi	r24, 0x0D	; 13
 62e:	a1 f0       	breq	.+40     	; 0x658 <processData+0x34>
 630:	18 f4       	brcc	.+6      	; 0x638 <processData+0x14>
 632:	8b 30       	cpi	r24, 0x0B	; 11
 634:	31 f0       	breq	.+12     	; 0x642 <processData+0x1e>
 636:	42 c0       	rjmp	.+132    	; 0x6bc <processData+0x98>
 638:	8f 30       	cpi	r24, 0x0F	; 15
 63a:	c9 f0       	breq	.+50     	; 0x66e <processData+0x4a>
 63c:	83 31       	cpi	r24, 0x13	; 19
 63e:	49 f1       	breq	.+82     	; 0x692 <processData+0x6e>
 640:	3d c0       	rjmp	.+122    	; 0x6bc <processData+0x98>
		case CMD_GET_ADC_DATA:
			if (CommIsFree())
 642:	bf de       	rcall	.-642    	; 0x3c2 <CommIsFree>
 644:	88 23       	and	r24, r24
 646:	d1 f1       	breq	.+116    	; 0x6bc <processData+0x98>
				CommSendData(ADDR_CTRL, ADDR_HEAD_UNIT, CMD_ADC_DATA, adcChannelsMonitored, adcBuff);
 648:	05 e2       	ldi	r16, 0x25	; 37
 64a:	12 e0       	ldi	r17, 0x02	; 2
 64c:	22 e0       	ldi	r18, 0x02	; 2
 64e:	4c e0       	ldi	r20, 0x0C	; 12
 650:	61 e0       	ldi	r22, 0x01	; 1
 652:	82 e0       	ldi	r24, 0x02	; 2
 654:	c5 de       	rcall	.-630    	; 0x3e0 <CommSendData>
			break;
			
		case CMD_GET_CONFIG:
			if (CommIsFree())
 656:	32 c0       	rjmp	.+100    	; 0x6bc <processData+0x98>
 658:	b4 de       	rcall	.-664    	; 0x3c2 <CommIsFree>
 65a:	88 23       	and	r24, r24
 65c:	79 f1       	breq	.+94     	; 0x6bc <processData+0x98>
				CommSendData(ADDR_CTRL, ADDR_HEAD_UNIT, CMD_CONFIG, sizeof(deviceConfig), (u08*)&deviceConfig);
 65e:	04 e7       	ldi	r16, 0x74	; 116
 660:	12 e0       	ldi	r17, 0x02	; 2
 662:	23 e0       	ldi	r18, 0x03	; 3
 664:	4e e0       	ldi	r20, 0x0E	; 14
 666:	61 e0       	ldi	r22, 0x01	; 1
 668:	82 e0       	ldi	r24, 0x02	; 2
 66a:	ba de       	rcall	.-652    	; 0x3e0 <CommSendData>
 66c:	27 c0       	rjmp	.+78     	; 0x6bc <processData+0x98>
			break;
			
		case CMD_SET_CONFIG:
			if (sizeof(deviceConfig) == df.Header.nDataLen) {
 66e:	80 91 7b 02 	lds	r24, 0x027B	; 0x80027b <df+0x4>
 672:	83 30       	cpi	r24, 0x03	; 3
 674:	19 f5       	brne	.+70     	; 0x6bc <processData+0x98>
				memcpy((u08*)&deviceConfig, df.Data, sizeof(deviceConfig));
 676:	80 91 7d 02 	lds	r24, 0x027D	; 0x80027d <df+0x6>
 67a:	90 91 7e 02 	lds	r25, 0x027E	; 0x80027e <df+0x7>
 67e:	a0 91 7f 02 	lds	r26, 0x027F	; 0x80027f <df+0x8>
 682:	80 93 74 02 	sts	0x0274, r24	; 0x800274 <deviceConfig>
 686:	90 93 75 02 	sts	0x0275, r25	; 0x800275 <deviceConfig+0x1>
 68a:	a0 93 76 02 	sts	0x0276, r26	; 0x800276 <deviceConfig+0x2>
				writeDeviceConfig();
 68e:	c2 df       	rcall	.-124    	; 0x614 <writeDeviceConfig>
 690:	15 c0       	rjmp	.+42     	; 0x6bc <processData+0x98>
			}
			break;
			
		case CMD_SET_DRL:
			drlForced = df.Data[0];
 692:	80 91 7d 02 	lds	r24, 0x027D	; 0x80027d <df+0x6>
 696:	80 93 21 02 	sts	0x0221, r24	; 0x800221 <drlForced>
			if (drlForced) {
 69a:	88 23       	and	r24, r24
 69c:	31 f0       	breq	.+12     	; 0x6aa <processData+0x86>
		switch (output) {
			case 0:
				PORTD |= (1 << PD7);
				break;
			case 1:
				PORTC |= (1 << PC1);
 69e:	41 9a       	sbi	0x08, 1	; 8
			
		case CMD_SET_DRL:
			drlForced = df.Data[0];
			if (drlForced) {
				toggleOutput(DRL_PIN, TRUE);
				prevLightsState = lightsState;
 6a0:	80 91 23 02 	lds	r24, 0x0223	; 0x800223 <lightsState>
 6a4:	80 93 22 02 	sts	0x0222, r24	; 0x800222 <prevLightsState>
 6a8:	09 c0       	rjmp	.+18     	; 0x6bc <processData+0x98>
			}
			else {
				if (prevLightsState == LIGHTS_STATE_ON)
 6aa:	80 91 22 02 	lds	r24, 0x0222	; 0x800222 <prevLightsState>
 6ae:	81 30       	cpi	r24, 0x01	; 1
 6b0:	09 f4       	brne	.+2      	; 0x6b4 <processData+0x90>
		switch (output) {
			case 0:
				PORTD &= ~(1 << PD7);
				break;
			case 1:
				PORTC &= ~(1 << PC1);
 6b2:	41 98       	cbi	0x08, 1	; 8
				prevLightsState = lightsState;
			}
			else {
				if (prevLightsState == LIGHTS_STATE_ON)
					toggleOutput(DRL_PIN, FALSE);
				lightsState = prevLightsState;
 6b4:	80 91 22 02 	lds	r24, 0x0222	; 0x800222 <prevLightsState>
 6b8:	80 93 23 02 	sts	0x0223, r24	; 0x800223 <lightsState>
			}
				
			break;
	}
}
 6bc:	1f 91       	pop	r17
 6be:	0f 91       	pop	r16
 6c0:	08 95       	ret

000006c2 <mainLoop>:
}

void mainLoop() {
	while (1)
	{
		if(data_GetData(&df)) {
 6c2:	87 e7       	ldi	r24, 0x77	; 119
 6c4:	92 e0       	ldi	r25, 0x02	; 2
 6c6:	40 d0       	rcall	.+128    	; 0x748 <data_GetData>
 6c8:	81 11       	cpse	r24, r1
			processData();
 6ca:	ac df       	rcall	.-168    	; 0x624 <processData>
		}
		
		processLights();
 6cc:	78 df       	rcall	.-272    	; 0x5be <processLights>
 6ce:	f9 cf       	rjmp	.-14     	; 0x6c2 <mainLoop>

000006d0 <main>:
	}
 6d0:	8e df       	rcall	.-228    	; 0x5ee <init>
BOOL firstRun = TRUE;

int main(void)
{
	init();
	mainLoop();
 6d2:	f7 df       	rcall	.-18     	; 0x6c2 <mainLoop>

000006d4 <data_SwapFrame>:
 6d4:	80 91 2b 02 	lds	r24, 0x022B	; 0x80022b <nCurrentFrame>
	data_SwapFrame();
}

void data_SwapFrame()
{
	if (nCurrentFrame == 0)
 6d8:	81 11       	cpse	r24, r1
 6da:	04 c0       	rjmp	.+8      	; 0x6e4 <data_SwapFrame+0x10>
		nCurrentFrame = 1;
 6dc:	81 e0       	ldi	r24, 0x01	; 1
 6de:	80 93 2b 02 	sts	0x022B, r24	; 0x80022b <nCurrentFrame>
 6e2:	08 95       	ret
	else
		nCurrentFrame = 0;
 6e4:	10 92 2b 02 	sts	0x022B, r1	; 0x80022b <nCurrentFrame>
 6e8:	08 95       	ret

000006ea <data_StartFrame>:
									unsigned char nAddressFrom, unsigned char nAddressTo);


void data_StartFrame()
{
	data_SwapFrame();
 6ea:	f4 df       	rcall	.-24     	; 0x6d4 <data_SwapFrame>
	nDataRecieved = 0;
 6ec:	10 92 29 02 	sts	0x0229, r1	; 0x800229 <nDataRecieved>
	memset(&df[nCurrentFrame], 0, sizeof(struct DataFrame));
 6f0:	e0 91 2b 02 	lds	r30, 0x022B	; 0x80022b <nCurrentFrame>
 6f4:	86 e4       	ldi	r24, 0x46	; 70
 6f6:	8e 9f       	mul	r24, r30
 6f8:	f0 01       	movw	r30, r0
 6fa:	11 24       	eor	r1, r1
 6fc:	e9 58       	subi	r30, 0x89	; 137
 6fe:	fd 4f       	sbci	r31, 0xFD	; 253
 700:	df 01       	movw	r26, r30
 702:	1d 92       	st	X+, r1
 704:	8a 95       	dec	r24
 706:	e9 f7       	brne	.-6      	; 0x702 <data_StartFrame+0x18>
 708:	08 95       	ret

0000070a <data_DropFrame>:
		data_DropFrame();
}

void data_DropFrame()
{
	nRecieveStep = 0;
 70a:	10 92 2a 02 	sts	0x022A, r1	; 0x80022a <nRecieveStep>
	nDataRecieved = 0;
 70e:	10 92 29 02 	sts	0x0229, r1	; 0x800229 <nDataRecieved>
	pRecievedFrame = NULL;
 712:	10 92 2d 02 	sts	0x022D, r1	; 0x80022d <pRecievedFrame+0x1>
 716:	10 92 2c 02 	sts	0x022C, r1	; 0x80022c <pRecievedFrame>
	data_SwapFrame();
 71a:	dc cf       	rjmp	.-72     	; 0x6d4 <data_SwapFrame>
 71c:	08 95       	ret

0000071e <data_SendNextByte>:
	}
}

BOOL data_SendNextByte(unsigned char* pData)
{
	*pData = OutputBuff[nCurrentByte++];
 71e:	e0 91 28 02 	lds	r30, 0x0228	; 0x800228 <nCurrentByte>
 722:	21 e0       	ldi	r18, 0x01	; 1
 724:	2e 0f       	add	r18, r30
 726:	20 93 28 02 	sts	0x0228, r18	; 0x800228 <nCurrentByte>
 72a:	f0 e0       	ldi	r31, 0x00	; 0
 72c:	ed 5f       	subi	r30, 0xFD	; 253
 72e:	fc 4f       	sbci	r31, 0xFC	; 252
 730:	20 81       	ld	r18, Z
 732:	fc 01       	movw	r30, r24
 734:	20 83       	st	Z, r18
	return nCurrentByte < nOutputBuffSize;
 736:	81 e0       	ldi	r24, 0x01	; 1
 738:	20 91 28 02 	lds	r18, 0x0228	; 0x800228 <nCurrentByte>
 73c:	90 91 27 02 	lds	r25, 0x0227	; 0x800227 <nOutputBuffSize>
 740:	29 17       	cp	r18, r25
 742:	08 f0       	brcs	.+2      	; 0x746 <data_SendNextByte+0x28>
 744:	80 e0       	ldi	r24, 0x00	; 0
}
 746:	08 95       	ret

00000748 <data_GetData>:
												  pdf->Header.nAddressFrom, pdf->Header.nAddressTo);
	memcpy(OutputBuff, pdf, nOutputBuffSize);
}

BOOL data_GetData(struct DataFrame* pdf)
{
 748:	dc 01       	movw	r26, r24
	if (pRecievedFrame != NULL)
 74a:	20 91 2c 02 	lds	r18, 0x022C	; 0x80022c <pRecievedFrame>
 74e:	30 91 2d 02 	lds	r19, 0x022D	; 0x80022d <pRecievedFrame+0x1>
 752:	23 2b       	or	r18, r19
 754:	89 f0       	breq	.+34     	; 0x778 <data_GetData+0x30>
	{
		cli();
 756:	f8 94       	cli
		*pdf = *pRecievedFrame;
 758:	e0 91 2c 02 	lds	r30, 0x022C	; 0x80022c <pRecievedFrame>
 75c:	f0 91 2d 02 	lds	r31, 0x022D	; 0x80022d <pRecievedFrame+0x1>
 760:	96 e4       	ldi	r25, 0x46	; 70
 762:	01 90       	ld	r0, Z+
 764:	0d 92       	st	X+, r0
 766:	9a 95       	dec	r25
 768:	e1 f7       	brne	.-8      	; 0x762 <data_GetData+0x1a>
		pRecievedFrame = NULL;	
 76a:	10 92 2d 02 	sts	0x022D, r1	; 0x80022d <pRecievedFrame+0x1>
 76e:	10 92 2c 02 	sts	0x022C, r1	; 0x80022c <pRecievedFrame>
		sei();
 772:	78 94       	sei
		return TRUE;
 774:	8f ef       	ldi	r24, 0xFF	; 255
 776:	08 95       	ret
	}

	return FALSE;	
 778:	80 e0       	ldi	r24, 0x00	; 0
}
 77a:	08 95       	ret

0000077c <data_CalcDataCheckSum>:

unsigned char data_CalcDataCheckSum(unsigned char* pData, unsigned char nDataLen, unsigned char nCmd, 
									unsigned char nAddressFrom, unsigned char nAddressTo)
{
 77c:	0f 93       	push	r16
	unsigned short sum;
	unsigned char  i;

	sum = nDataLen + nCmd + nAddressFrom + nAddressTo;

	if (nDataLen > DATA_MAX_LEN) return 0;
 77e:	61 34       	cpi	r22, 0x41	; 65
 780:	d0 f4       	brcc	.+52     	; 0x7b6 <data_CalcDataCheckSum+0x3a>
									unsigned char nAddressFrom, unsigned char nAddressTo)
{
	unsigned short sum;
	unsigned char  i;

	sum = nDataLen + nCmd + nAddressFrom + nAddressTo;
 782:	50 e0       	ldi	r21, 0x00	; 0
 784:	46 0f       	add	r20, r22
 786:	51 1d       	adc	r21, r1
 788:	fa 01       	movw	r30, r20
 78a:	e2 0f       	add	r30, r18
 78c:	f1 1d       	adc	r31, r1
 78e:	9f 01       	movw	r18, r30
 790:	20 0f       	add	r18, r16
 792:	31 1d       	adc	r19, r1

	if (nDataLen > DATA_MAX_LEN) return 0;

	for(i=0; i<nDataLen; i++)
 794:	66 23       	and	r22, r22
 796:	69 f0       	breq	.+26     	; 0x7b2 <data_CalcDataCheckSum+0x36>
 798:	fc 01       	movw	r30, r24
 79a:	61 50       	subi	r22, 0x01	; 1
 79c:	70 e0       	ldi	r23, 0x00	; 0
 79e:	6f 5f       	subi	r22, 0xFF	; 255
 7a0:	7f 4f       	sbci	r23, 0xFF	; 255
 7a2:	86 0f       	add	r24, r22
 7a4:	97 1f       	adc	r25, r23
	{
		sum += pData[i];
 7a6:	41 91       	ld	r20, Z+
 7a8:	24 0f       	add	r18, r20
 7aa:	31 1d       	adc	r19, r1

	sum = nDataLen + nCmd + nAddressFrom + nAddressTo;

	if (nDataLen > DATA_MAX_LEN) return 0;

	for(i=0; i<nDataLen; i++)
 7ac:	e8 17       	cp	r30, r24
 7ae:	f9 07       	cpc	r31, r25
 7b0:	d1 f7       	brne	.-12     	; 0x7a6 <data_CalcDataCheckSum+0x2a>
	{
		sum += pData[i];
	}

	return sum % 256;
 7b2:	82 2f       	mov	r24, r18
 7b4:	01 c0       	rjmp	.+2      	; 0x7b8 <data_CalcDataCheckSum+0x3c>
	unsigned short sum;
	unsigned char  i;

	sum = nDataLen + nCmd + nAddressFrom + nAddressTo;

	if (nDataLen > DATA_MAX_LEN) return 0;
 7b6:	80 e0       	ldi	r24, 0x00	; 0
	{
		sum += pData[i];
	}

	return sum % 256;
}
 7b8:	0f 91       	pop	r16
 7ba:	08 95       	ret

000007bc <data_FinishFrame>:
	nDataRecieved = 0;
	memset(&df[nCurrentFrame], 0, sizeof(struct DataFrame));
}

void data_FinishFrame()
{
 7bc:	ef 92       	push	r14
 7be:	ff 92       	push	r15
 7c0:	0f 93       	push	r16
 7c2:	cf 93       	push	r28
 7c4:	df 93       	push	r29
	unsigned char nCheckSum = data_CalcDataCheckSum(df[nCurrentFrame].Data, 
 7c6:	80 91 2b 02 	lds	r24, 0x022B	; 0x80022b <nCurrentFrame>
 7ca:	e8 2e       	mov	r14, r24
 7cc:	f1 2c       	mov	r15, r1
 7ce:	26 e4       	ldi	r18, 0x46	; 70
 7d0:	82 9f       	mul	r24, r18
 7d2:	c0 01       	movw	r24, r0
 7d4:	11 24       	eor	r1, r1
 7d6:	ec 01       	movw	r28, r24
 7d8:	c9 58       	subi	r28, 0x89	; 137
 7da:	dd 4f       	sbci	r29, 0xFD	; 253
 7dc:	0a 81       	ldd	r16, Y+2	; 0x02
 7de:	29 81       	ldd	r18, Y+1	; 0x01
 7e0:	4b 81       	ldd	r20, Y+3	; 0x03
 7e2:	6c 81       	ldd	r22, Y+4	; 0x04
 7e4:	83 58       	subi	r24, 0x83	; 131
 7e6:	9d 4f       	sbci	r25, 0xFD	; 253
 7e8:	c9 df       	rcall	.-110    	; 0x77c <data_CalcDataCheckSum>
										   df[nCurrentFrame].Header.nDataLen,
										   df[nCurrentFrame].Header.nCmd,
										   df[nCurrentFrame].Header.nAddressFrom,
										   df[nCurrentFrame].Header.nAddressTo);

	nRecieveStep = 0;
 7ea:	10 92 2a 02 	sts	0x022A, r1	; 0x80022a <nRecieveStep>
	nDataRecieved = 0;
 7ee:	10 92 29 02 	sts	0x0229, r1	; 0x800229 <nDataRecieved>

	if (df[nCurrentFrame].Header.nCheckSum == nCheckSum) 
 7f2:	9d 81       	ldd	r25, Y+5	; 0x05
 7f4:	89 13       	cpse	r24, r25
 7f6:	0d c0       	rjmp	.+26     	; 0x812 <data_FinishFrame+0x56>
		pRecievedFrame = &df[nCurrentFrame];
 7f8:	26 e4       	ldi	r18, 0x46	; 70
 7fa:	2e 9d       	mul	r18, r14
 7fc:	c0 01       	movw	r24, r0
 7fe:	2f 9d       	mul	r18, r15
 800:	90 0d       	add	r25, r0
 802:	11 24       	eor	r1, r1
 804:	89 58       	subi	r24, 0x89	; 137
 806:	9d 4f       	sbci	r25, 0xFD	; 253
 808:	90 93 2d 02 	sts	0x022D, r25	; 0x80022d <pRecievedFrame+0x1>
 80c:	80 93 2c 02 	sts	0x022C, r24	; 0x80022c <pRecievedFrame>
	else
		data_DropFrame();
 810:	01 c0       	rjmp	.+2      	; 0x814 <data_FinishFrame+0x58>
 812:	7b df       	rcall	.-266    	; 0x70a <data_DropFrame>
}
 814:	df 91       	pop	r29
 816:	cf 91       	pop	r28
 818:	0f 91       	pop	r16
 81a:	ff 90       	pop	r15
 81c:	ef 90       	pop	r14
 81e:	08 95       	ret

00000820 <data_RecieveByte>:
		nCurrentFrame = 0;
}

void data_RecieveByte(unsigned char nData)
{
	switch(nRecieveStep)
 820:	40 91 2a 02 	lds	r20, 0x022A	; 0x80022a <nRecieveStep>
 824:	50 e0       	ldi	r21, 0x00	; 0
 826:	47 30       	cpi	r20, 0x07	; 7
 828:	51 05       	cpc	r21, r1
 82a:	08 f0       	brcs	.+2      	; 0x82e <data_RecieveByte+0xe>
 82c:	86 c0       	rjmp	.+268    	; 0x93a <data_RecieveByte+0x11a>
 82e:	98 2f       	mov	r25, r24
 830:	fa 01       	movw	r30, r20
 832:	88 27       	eor	r24, r24
 834:	e5 58       	subi	r30, 0x85	; 133
 836:	ff 4f       	sbci	r31, 0xFF	; 255
 838:	8f 4f       	sbci	r24, 0xFF	; 255
 83a:	6f c1       	rjmp	.+734    	; 0xb1a <__tablejump2__>
	{
		case 0:
			if (nData != START_BYTE)
 83c:	9a 3a       	cpi	r25, 0xAA	; 170
 83e:	09 f0       	breq	.+2      	; 0x842 <data_RecieveByte+0x22>
				return;
			data_StartFrame();
 840:	7c c0       	rjmp	.+248    	; 0x93a <data_RecieveByte+0x11a>
 842:	53 df       	rcall	.-346    	; 0x6ea <data_StartFrame>
			df[nCurrentFrame].Header.nStart = nData;			
 844:	e0 91 2b 02 	lds	r30, 0x022B	; 0x80022b <nCurrentFrame>
 848:	36 e4       	ldi	r19, 0x46	; 70
 84a:	e3 9f       	mul	r30, r19
 84c:	f0 01       	movw	r30, r0
 84e:	11 24       	eor	r1, r1
 850:	e9 58       	subi	r30, 0x89	; 137
 852:	fd 4f       	sbci	r31, 0xFD	; 253
 854:	8a ea       	ldi	r24, 0xAA	; 170
 856:	80 83       	st	Z, r24
			nRecieveStep++;
 858:	80 91 2a 02 	lds	r24, 0x022A	; 0x80022a <nRecieveStep>
 85c:	8f 5f       	subi	r24, 0xFF	; 255
 85e:	80 93 2a 02 	sts	0x022A, r24	; 0x80022a <nRecieveStep>
			break;
 862:	08 95       	ret

		case 1:
			df[nCurrentFrame].Header.nAddressFrom = nData;
 864:	e0 91 2b 02 	lds	r30, 0x022B	; 0x80022b <nCurrentFrame>
 868:	86 e4       	ldi	r24, 0x46	; 70
 86a:	e8 9f       	mul	r30, r24
 86c:	f0 01       	movw	r30, r0
 86e:	11 24       	eor	r1, r1
 870:	e9 58       	subi	r30, 0x89	; 137
 872:	fd 4f       	sbci	r31, 0xFD	; 253
 874:	91 83       	std	Z+1, r25	; 0x01
			nRecieveStep++;
 876:	82 e0       	ldi	r24, 0x02	; 2
 878:	80 93 2a 02 	sts	0x022A, r24	; 0x80022a <nRecieveStep>
			break;
 87c:	08 95       	ret

		case 2:
			df[nCurrentFrame].Header.nAddressTo = nData;
 87e:	e0 91 2b 02 	lds	r30, 0x022B	; 0x80022b <nCurrentFrame>
 882:	36 e4       	ldi	r19, 0x46	; 70
 884:	e3 9f       	mul	r30, r19
 886:	f0 01       	movw	r30, r0
 888:	11 24       	eor	r1, r1
 88a:	e9 58       	subi	r30, 0x89	; 137
 88c:	fd 4f       	sbci	r31, 0xFD	; 253
 88e:	92 83       	std	Z+2, r25	; 0x02
			nRecieveStep++;
 890:	83 e0       	ldi	r24, 0x03	; 3
 892:	80 93 2a 02 	sts	0x022A, r24	; 0x80022a <nRecieveStep>
			break;
 896:	08 95       	ret

		case 3:
			df[nCurrentFrame].Header.nCmd = nData;
 898:	e0 91 2b 02 	lds	r30, 0x022B	; 0x80022b <nCurrentFrame>
 89c:	86 e4       	ldi	r24, 0x46	; 70
 89e:	e8 9f       	mul	r30, r24
 8a0:	f0 01       	movw	r30, r0
 8a2:	11 24       	eor	r1, r1
 8a4:	e9 58       	subi	r30, 0x89	; 137
 8a6:	fd 4f       	sbci	r31, 0xFD	; 253
 8a8:	93 83       	std	Z+3, r25	; 0x03
			nRecieveStep++;
 8aa:	84 e0       	ldi	r24, 0x04	; 4
 8ac:	80 93 2a 02 	sts	0x022A, r24	; 0x80022a <nRecieveStep>
			break;
 8b0:	08 95       	ret

		case 4:
			if (nData > DATA_MAX_LEN)
 8b2:	91 34       	cpi	r25, 0x41	; 65
			{
				data_DropFrame();
 8b4:	10 f0       	brcs	.+4      	; 0x8ba <data_RecieveByte+0x9a>
 8b6:	29 cf       	rjmp	.-430    	; 0x70a <data_DropFrame>
				return;
 8b8:	08 95       	ret
			}

			df[nCurrentFrame].Header.nDataLen = nData;
 8ba:	e0 91 2b 02 	lds	r30, 0x022B	; 0x80022b <nCurrentFrame>
 8be:	36 e4       	ldi	r19, 0x46	; 70
 8c0:	e3 9f       	mul	r30, r19
 8c2:	f0 01       	movw	r30, r0
 8c4:	11 24       	eor	r1, r1
 8c6:	e9 58       	subi	r30, 0x89	; 137
 8c8:	fd 4f       	sbci	r31, 0xFD	; 253
 8ca:	94 83       	std	Z+4, r25	; 0x04
			nRecieveStep++;
 8cc:	85 e0       	ldi	r24, 0x05	; 5
 8ce:	80 93 2a 02 	sts	0x022A, r24	; 0x80022a <nRecieveStep>
			break;
 8d2:	08 95       	ret

		case 5:
			df[nCurrentFrame].Header.nCheckSum = nData;
 8d4:	e0 91 2b 02 	lds	r30, 0x022B	; 0x80022b <nCurrentFrame>
 8d8:	86 e4       	ldi	r24, 0x46	; 70
 8da:	e8 9f       	mul	r30, r24
 8dc:	f0 01       	movw	r30, r0
 8de:	11 24       	eor	r1, r1
 8e0:	e9 58       	subi	r30, 0x89	; 137
 8e2:	fd 4f       	sbci	r31, 0xFD	; 253
 8e4:	95 83       	std	Z+5, r25	; 0x05
			if (df[nCurrentFrame].Header.nDataLen == 0)
 8e6:	84 81       	ldd	r24, Z+4	; 0x04
 8e8:	88 23       	and	r24, r24
 8ea:	31 f1       	breq	.+76     	; 0x938 <data_RecieveByte+0x118>
			{
				goto end_revieve;
			}
			nRecieveStep++;
 8ec:	86 e0       	ldi	r24, 0x06	; 6
 8ee:	80 93 2a 02 	sts	0x022A, r24	; 0x80022a <nRecieveStep>
			break;
 8f2:	08 95       	ret

		case 6:		
			df[nCurrentFrame].Data[nDataRecieved++] = nData;
 8f4:	e0 91 2b 02 	lds	r30, 0x022B	; 0x80022b <nCurrentFrame>
 8f8:	20 91 29 02 	lds	r18, 0x0229	; 0x800229 <nDataRecieved>
 8fc:	81 e0       	ldi	r24, 0x01	; 1
 8fe:	82 0f       	add	r24, r18
 900:	80 93 29 02 	sts	0x0229, r24	; 0x800229 <nDataRecieved>
 904:	4e 2f       	mov	r20, r30
 906:	50 e0       	ldi	r21, 0x00	; 0
 908:	36 e4       	ldi	r19, 0x46	; 70
 90a:	e3 9f       	mul	r30, r19
 90c:	f0 01       	movw	r30, r0
 90e:	11 24       	eor	r1, r1
 910:	e9 58       	subi	r30, 0x89	; 137
 912:	fd 4f       	sbci	r31, 0xFD	; 253
 914:	e2 0f       	add	r30, r18
 916:	f1 1d       	adc	r31, r1
			
			if (nDataRecieved > DATA_MAX_LEN)
 918:	96 83       	std	Z+6, r25	; 0x06
 91a:	81 34       	cpi	r24, 0x41	; 65
			{
				data_DropFrame();
 91c:	10 f0       	brcs	.+4      	; 0x922 <data_RecieveByte+0x102>
 91e:	f5 ce       	rjmp	.-534    	; 0x70a <data_DropFrame>
				return;
 920:	08 95       	ret
			}
			
			if (nDataRecieved == df[nCurrentFrame].Header.nDataLen)
 922:	96 e4       	ldi	r25, 0x46	; 70
 924:	94 9f       	mul	r25, r20
 926:	f0 01       	movw	r30, r0
 928:	95 9f       	mul	r25, r21
 92a:	f0 0d       	add	r31, r0
 92c:	11 24       	eor	r1, r1
 92e:	e9 58       	subi	r30, 0x89	; 137
 930:	fd 4f       	sbci	r31, 0xFD	; 253
 932:	94 81       	ldd	r25, Z+4	; 0x04
 934:	89 13       	cpse	r24, r25
			{
end_revieve:
				data_FinishFrame();
 936:	01 c0       	rjmp	.+2      	; 0x93a <data_RecieveByte+0x11a>
 938:	41 cf       	rjmp	.-382    	; 0x7bc <data_FinishFrame>
 93a:	08 95       	ret

0000093c <data_SendFrame>:
	*pData = OutputBuff[nCurrentByte++];
	return nCurrentByte < nOutputBuffSize;
}

void data_SendFrame(struct DataFrame* pdf)
{
 93c:	0f 93       	push	r16
 93e:	cf 93       	push	r28
 940:	df 93       	push	r29
 942:	ec 01       	movw	r28, r24
	nCurrentByte = 0;
 944:	10 92 28 02 	sts	0x0228, r1	; 0x800228 <nCurrentByte>
	nOutputBuffSize = sizeof(struct DataFrameHeader) + pdf->Header.nDataLen;
 948:	6c 81       	ldd	r22, Y+4	; 0x04
 94a:	86 e0       	ldi	r24, 0x06	; 6
 94c:	86 0f       	add	r24, r22
 94e:	80 93 27 02 	sts	0x0227, r24	; 0x800227 <nOutputBuffSize>
	pdf->Header.nStart = START_BYTE;
 952:	8a ea       	ldi	r24, 0xAA	; 170
 954:	88 83       	st	Y, r24
	pdf->Header.nCheckSum = data_CalcDataCheckSum(pdf->Data, pdf->Header.nDataLen, pdf->Header.nCmd, 
 956:	0a 81       	ldd	r16, Y+2	; 0x02
 958:	29 81       	ldd	r18, Y+1	; 0x01
 95a:	4b 81       	ldd	r20, Y+3	; 0x03
 95c:	ce 01       	movw	r24, r28
 95e:	06 96       	adiw	r24, 0x06	; 6
 960:	0d df       	rcall	.-486    	; 0x77c <data_CalcDataCheckSum>
 962:	8d 83       	std	Y+5, r24	; 0x05
												  pdf->Header.nAddressFrom, pdf->Header.nAddressTo);
	memcpy(OutputBuff, pdf, nOutputBuffSize);
 964:	40 91 27 02 	lds	r20, 0x0227	; 0x800227 <nOutputBuffSize>
 968:	50 e0       	ldi	r21, 0x00	; 0
 96a:	be 01       	movw	r22, r28
 96c:	83 e0       	ldi	r24, 0x03	; 3
 96e:	93 e0       	ldi	r25, 0x03	; 3
 970:	dc d0       	rcall	.+440    	; 0xb2a <memcpy>
}
 972:	df 91       	pop	r29
 974:	cf 91       	pop	r28
 976:	0f 91       	pop	r16
 978:	08 95       	ret

0000097a <DummyUartCallback>:
	if (pNewCallback != NULL)
		UartTxCallback = pNewCallback;
}


void DummyUartCallback() {}
 97a:	08 95       	ret

0000097c <uartInit>:
volatile static voidFunc UartRxCallback = DummyUartCallback;
volatile static voidFunc UartTxCallback = DummyUartCallback;

void uartInit(void)
{
	outb(UCSR0B, BV(RXCIE0)|BV(TXCIE0)|BV(RXEN0)|BV(TXEN0));
 97c:	88 ed       	ldi	r24, 0xD8	; 216
 97e:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7c00c1>

void uartSetBaudRate(u32 nBaudrate)
{
	// calculate division factor for requested baud rate, and set it
	u16 bauddiv = ((F_CPU+(nBaudrate*8L))/(nBaudrate*16L)-1);
	outb(UBRR0L, bauddiv);
 982:	87 e6       	ldi	r24, 0x67	; 103
 984:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7c00c4>
	#ifdef UBRR0H
	outb(UBRR0H, bauddiv>>8);
 988:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7c00c5>

void uartInit(void)
{
	outb(UCSR0B, BV(RXCIE0)|BV(TXCIE0)|BV(RXEN0)|BV(TXEN0));
	uartSetBaudRate(UART_DEFAULT_BAUD_RATE); 
	sei();
 98c:	78 94       	sei
 98e:	08 95       	ret

00000990 <uartSetBaudRate>:
}

void uartSetBaudRate(u32 nBaudrate)
{
 990:	0f 93       	push	r16
 992:	1f 93       	push	r17
 994:	8b 01       	movw	r16, r22
 996:	9c 01       	movw	r18, r24
	// calculate division factor for requested baud rate, and set it
	u16 bauddiv = ((F_CPU+(nBaudrate*8L))/(nBaudrate*16L)-1);
 998:	dc 01       	movw	r26, r24
 99a:	cb 01       	movw	r24, r22
 99c:	80 58       	subi	r24, 0x80	; 128
 99e:	9b 47       	sbci	r25, 0x7B	; 123
 9a0:	a1 4e       	sbci	r26, 0xE1	; 225
 9a2:	bf 4f       	sbci	r27, 0xFF	; 255
 9a4:	88 0f       	add	r24, r24
 9a6:	99 1f       	adc	r25, r25
 9a8:	aa 1f       	adc	r26, r26
 9aa:	bb 1f       	adc	r27, r27
 9ac:	88 0f       	add	r24, r24
 9ae:	99 1f       	adc	r25, r25
 9b0:	aa 1f       	adc	r26, r26
 9b2:	bb 1f       	adc	r27, r27
 9b4:	bc 01       	movw	r22, r24
 9b6:	cd 01       	movw	r24, r26
 9b8:	66 0f       	add	r22, r22
 9ba:	77 1f       	adc	r23, r23
 9bc:	88 1f       	adc	r24, r24
 9be:	99 1f       	adc	r25, r25
 9c0:	00 0f       	add	r16, r16
 9c2:	11 1f       	adc	r17, r17
 9c4:	22 1f       	adc	r18, r18
 9c6:	33 1f       	adc	r19, r19
 9c8:	00 0f       	add	r16, r16
 9ca:	11 1f       	adc	r17, r17
 9cc:	22 1f       	adc	r18, r18
 9ce:	33 1f       	adc	r19, r19
 9d0:	a9 01       	movw	r20, r18
 9d2:	98 01       	movw	r18, r16
 9d4:	22 0f       	add	r18, r18
 9d6:	33 1f       	adc	r19, r19
 9d8:	44 1f       	adc	r20, r20
 9da:	55 1f       	adc	r21, r21
 9dc:	22 0f       	add	r18, r18
 9de:	33 1f       	adc	r19, r19
 9e0:	44 1f       	adc	r20, r20
 9e2:	55 1f       	adc	r21, r21
 9e4:	78 d0       	rcall	.+240    	; 0xad6 <__udivmodsi4>
 9e6:	21 50       	subi	r18, 0x01	; 1
 9e8:	31 09       	sbc	r19, r1
	outb(UBRR0L, bauddiv);
 9ea:	20 93 c4 00 	sts	0x00C4, r18	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7c00c4>
	#ifdef UBRR0H
	outb(UBRR0H, bauddiv>>8);
 9ee:	30 93 c5 00 	sts	0x00C5, r19	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7c00c5>
	#endif
}
 9f2:	1f 91       	pop	r17
 9f4:	0f 91       	pop	r16
 9f6:	08 95       	ret

000009f8 <uartSendByte>:

void uartSendByte(u08 txData)
{
	while(!(UCSR0A & (1<<UDRE0)));
 9f8:	e0 ec       	ldi	r30, 0xC0	; 192
 9fa:	f0 e0       	ldi	r31, 0x00	; 0
 9fc:	90 81       	ld	r25, Z
 9fe:	95 ff       	sbrs	r25, 5
 a00:	fd cf       	rjmp	.-6      	; 0x9fc <uartSendByte+0x4>
	outb(UDR0, txData);
 a02:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7c00c6>
 a06:	08 95       	ret

00000a08 <uartRecieveByte>:
}

u08 uartRecieveByte()
{
	return inb(UDR0);
 a08:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7c00c6>
}
 a0c:	08 95       	ret

00000a0e <uartSetRxCallback>:

void uartSetRxCallback(voidFunc pNewCallback)
{
	if (pNewCallback != NULL)
 a0e:	00 97       	sbiw	r24, 0x00	; 0
 a10:	21 f0       	breq	.+8      	; 0xa1a <uartSetRxCallback+0xc>
		UartRxCallback = pNewCallback;
 a12:	90 93 09 02 	sts	0x0209, r25	; 0x800209 <UartRxCallback+0x1>
 a16:	80 93 08 02 	sts	0x0208, r24	; 0x800208 <UartRxCallback>
 a1a:	08 95       	ret

00000a1c <uartSetTxCallback>:
}

void uartSetTxCallback(voidFunc pNewCallback)
{
	if (pNewCallback != NULL)
 a1c:	00 97       	sbiw	r24, 0x00	; 0
 a1e:	21 f0       	breq	.+8      	; 0xa28 <uartSetTxCallback+0xc>
		UartTxCallback = pNewCallback;
 a20:	90 93 07 02 	sts	0x0207, r25	; 0x800207 <UartTxCallback+0x1>
 a24:	80 93 06 02 	sts	0x0206, r24	; 0x800206 <UartTxCallback>
 a28:	08 95       	ret

00000a2a <__vector_25>:


void DummyUartCallback() {}

ISR(USART0_RX_vect)      
{
 a2a:	1f 92       	push	r1
 a2c:	0f 92       	push	r0
 a2e:	0f b6       	in	r0, 0x3f	; 63
 a30:	0f 92       	push	r0
 a32:	11 24       	eor	r1, r1
 a34:	0b b6       	in	r0, 0x3b	; 59
 a36:	0f 92       	push	r0
 a38:	2f 93       	push	r18
 a3a:	3f 93       	push	r19
 a3c:	4f 93       	push	r20
 a3e:	5f 93       	push	r21
 a40:	6f 93       	push	r22
 a42:	7f 93       	push	r23
 a44:	8f 93       	push	r24
 a46:	9f 93       	push	r25
 a48:	af 93       	push	r26
 a4a:	bf 93       	push	r27
 a4c:	ef 93       	push	r30
 a4e:	ff 93       	push	r31
	UartRxCallback();
 a50:	e0 91 08 02 	lds	r30, 0x0208	; 0x800208 <UartRxCallback>
 a54:	f0 91 09 02 	lds	r31, 0x0209	; 0x800209 <UartRxCallback+0x1>
 a58:	19 95       	eicall
}
 a5a:	ff 91       	pop	r31
 a5c:	ef 91       	pop	r30
 a5e:	bf 91       	pop	r27
 a60:	af 91       	pop	r26
 a62:	9f 91       	pop	r25
 a64:	8f 91       	pop	r24
 a66:	7f 91       	pop	r23
 a68:	6f 91       	pop	r22
 a6a:	5f 91       	pop	r21
 a6c:	4f 91       	pop	r20
 a6e:	3f 91       	pop	r19
 a70:	2f 91       	pop	r18
 a72:	0f 90       	pop	r0
 a74:	0b be       	out	0x3b, r0	; 59
 a76:	0f 90       	pop	r0
 a78:	0f be       	out	0x3f, r0	; 63
 a7a:	0f 90       	pop	r0
 a7c:	1f 90       	pop	r1
 a7e:	18 95       	reti

00000a80 <__vector_27>:

ISR(USART0_TX_vect)      
{
 a80:	1f 92       	push	r1
 a82:	0f 92       	push	r0
 a84:	0f b6       	in	r0, 0x3f	; 63
 a86:	0f 92       	push	r0
 a88:	11 24       	eor	r1, r1
 a8a:	0b b6       	in	r0, 0x3b	; 59
 a8c:	0f 92       	push	r0
 a8e:	2f 93       	push	r18
 a90:	3f 93       	push	r19
 a92:	4f 93       	push	r20
 a94:	5f 93       	push	r21
 a96:	6f 93       	push	r22
 a98:	7f 93       	push	r23
 a9a:	8f 93       	push	r24
 a9c:	9f 93       	push	r25
 a9e:	af 93       	push	r26
 aa0:	bf 93       	push	r27
 aa2:	ef 93       	push	r30
 aa4:	ff 93       	push	r31
	UartTxCallback();
 aa6:	e0 91 06 02 	lds	r30, 0x0206	; 0x800206 <UartTxCallback>
 aaa:	f0 91 07 02 	lds	r31, 0x0207	; 0x800207 <UartTxCallback+0x1>
 aae:	19 95       	eicall
}
 ab0:	ff 91       	pop	r31
 ab2:	ef 91       	pop	r30
 ab4:	bf 91       	pop	r27
 ab6:	af 91       	pop	r26
 ab8:	9f 91       	pop	r25
 aba:	8f 91       	pop	r24
 abc:	7f 91       	pop	r23
 abe:	6f 91       	pop	r22
 ac0:	5f 91       	pop	r21
 ac2:	4f 91       	pop	r20
 ac4:	3f 91       	pop	r19
 ac6:	2f 91       	pop	r18
 ac8:	0f 90       	pop	r0
 aca:	0b be       	out	0x3b, r0	; 59
 acc:	0f 90       	pop	r0
 ace:	0f be       	out	0x3f, r0	; 63
 ad0:	0f 90       	pop	r0
 ad2:	1f 90       	pop	r1
 ad4:	18 95       	reti

00000ad6 <__udivmodsi4>:
 ad6:	a1 e2       	ldi	r26, 0x21	; 33
 ad8:	1a 2e       	mov	r1, r26
 ada:	aa 1b       	sub	r26, r26
 adc:	bb 1b       	sub	r27, r27
 ade:	fd 01       	movw	r30, r26
 ae0:	0d c0       	rjmp	.+26     	; 0xafc <__udivmodsi4_ep>

00000ae2 <__udivmodsi4_loop>:
 ae2:	aa 1f       	adc	r26, r26
 ae4:	bb 1f       	adc	r27, r27
 ae6:	ee 1f       	adc	r30, r30
 ae8:	ff 1f       	adc	r31, r31
 aea:	a2 17       	cp	r26, r18
 aec:	b3 07       	cpc	r27, r19
 aee:	e4 07       	cpc	r30, r20
 af0:	f5 07       	cpc	r31, r21
 af2:	20 f0       	brcs	.+8      	; 0xafc <__udivmodsi4_ep>
 af4:	a2 1b       	sub	r26, r18
 af6:	b3 0b       	sbc	r27, r19
 af8:	e4 0b       	sbc	r30, r20
 afa:	f5 0b       	sbc	r31, r21

00000afc <__udivmodsi4_ep>:
 afc:	66 1f       	adc	r22, r22
 afe:	77 1f       	adc	r23, r23
 b00:	88 1f       	adc	r24, r24
 b02:	99 1f       	adc	r25, r25
 b04:	1a 94       	dec	r1
 b06:	69 f7       	brne	.-38     	; 0xae2 <__udivmodsi4_loop>
 b08:	60 95       	com	r22
 b0a:	70 95       	com	r23
 b0c:	80 95       	com	r24
 b0e:	90 95       	com	r25
 b10:	9b 01       	movw	r18, r22
 b12:	ac 01       	movw	r20, r24
 b14:	bd 01       	movw	r22, r26
 b16:	cf 01       	movw	r24, r30
 b18:	08 95       	ret

00000b1a <__tablejump2__>:
 b1a:	ee 0f       	add	r30, r30
 b1c:	ff 1f       	adc	r31, r31
 b1e:	88 1f       	adc	r24, r24
 b20:	8b bf       	out	0x3b, r24	; 59
 b22:	07 90       	elpm	r0, Z+
 b24:	f6 91       	elpm	r31, Z
 b26:	e0 2d       	mov	r30, r0
 b28:	19 94       	eijmp

00000b2a <memcpy>:
 b2a:	fb 01       	movw	r30, r22
 b2c:	dc 01       	movw	r26, r24
 b2e:	02 c0       	rjmp	.+4      	; 0xb34 <memcpy+0xa>
 b30:	01 90       	ld	r0, Z+
 b32:	0d 92       	st	X+, r0
 b34:	41 50       	subi	r20, 0x01	; 1
 b36:	50 40       	sbci	r21, 0x00	; 0
 b38:	d8 f7       	brcc	.-10     	; 0xb30 <memcpy+0x6>
 b3a:	08 95       	ret

00000b3c <eeprom_read_block>:
 b3c:	dc 01       	movw	r26, r24
 b3e:	cb 01       	movw	r24, r22

00000b40 <eeprom_read_blraw>:
 b40:	fc 01       	movw	r30, r24
 b42:	f9 99       	sbic	0x1f, 1	; 31
 b44:	fe cf       	rjmp	.-4      	; 0xb42 <eeprom_read_blraw+0x2>
 b46:	06 c0       	rjmp	.+12     	; 0xb54 <eeprom_read_blraw+0x14>
 b48:	f2 bd       	out	0x22, r31	; 34
 b4a:	e1 bd       	out	0x21, r30	; 33
 b4c:	f8 9a       	sbi	0x1f, 0	; 31
 b4e:	31 96       	adiw	r30, 0x01	; 1
 b50:	00 b4       	in	r0, 0x20	; 32
 b52:	0d 92       	st	X+, r0
 b54:	41 50       	subi	r20, 0x01	; 1
 b56:	50 40       	sbci	r21, 0x00	; 0
 b58:	b8 f7       	brcc	.-18     	; 0xb48 <eeprom_read_blraw+0x8>
 b5a:	08 95       	ret

00000b5c <eeprom_write_block>:
 b5c:	dc 01       	movw	r26, r24
 b5e:	cb 01       	movw	r24, r22
 b60:	02 c0       	rjmp	.+4      	; 0xb66 <eeprom_write_block+0xa>
 b62:	2d 91       	ld	r18, X+
 b64:	05 d0       	rcall	.+10     	; 0xb70 <eeprom_write_r18>
 b66:	41 50       	subi	r20, 0x01	; 1
 b68:	50 40       	sbci	r21, 0x00	; 0
 b6a:	d8 f7       	brcc	.-10     	; 0xb62 <eeprom_write_block+0x6>
 b6c:	08 95       	ret

00000b6e <eeprom_write_byte>:
 b6e:	26 2f       	mov	r18, r22

00000b70 <eeprom_write_r18>:
 b70:	f9 99       	sbic	0x1f, 1	; 31
 b72:	fe cf       	rjmp	.-4      	; 0xb70 <eeprom_write_r18>
 b74:	1f ba       	out	0x1f, r1	; 31
 b76:	92 bd       	out	0x22, r25	; 34
 b78:	81 bd       	out	0x21, r24	; 33
 b7a:	20 bd       	out	0x20, r18	; 32
 b7c:	0f b6       	in	r0, 0x3f	; 63
 b7e:	f8 94       	cli
 b80:	fa 9a       	sbi	0x1f, 2	; 31
 b82:	f9 9a       	sbi	0x1f, 1	; 31
 b84:	0f be       	out	0x3f, r0	; 63
 b86:	01 96       	adiw	r24, 0x01	; 1
 b88:	08 95       	ret

00000b8a <_exit>:
 b8a:	f8 94       	cli

00000b8c <__stop_program>:
 b8c:	ff cf       	rjmp	.-2      	; 0xb8c <__stop_program>
